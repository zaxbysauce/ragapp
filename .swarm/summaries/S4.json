{"id":"S4","summaryText":"[SUMMARY S4] 40.0 KB | code | 872 lines\n============================= test session starts =============================\r\nplatform win32 -- Python 3.13.1, pytest-9.0.2, pluggy-1.6.0 -- C:\\Program Files\\Python313\\python.exe\r\ncachedir: .pytest_cache\r\nrootdir: C:\\opencode\\RAGAPPv2\\backend\r\nplugins: asyncio-1.3.0, cov-7.0.0, mock-3.15.1, anyio-4.12.1\r\nâ†’ Use /swarm retrieve S4 for full content","fullOutput":"============================= test session starts =============================\r\nplatform win32 -- Python 3.13.1, pytest-9.0.2, pluggy-1.6.0 -- C:\\Program Files\\Python313\\python.exe\r\ncachedir: .pytest_cache\r\nrootdir: C:\\opencode\\RAGAPPv2\\backend\r\nplugins: asyncio-1.3.0, cov-7.0.0, mock-3.15.1, anyio-4.12.1\r\nasyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function\r\ncollecting ... collected 171 items / 155 deselected / 16 selected\r\n\r\ntests/test_api_routes.py::TestDocumentsEndpoints::test_get_document_stats_empty PASSED [  6%]\r\ntests/test_api_routes.py::TestDocumentsEndpoints::test_list_documents_empty PASSED [ 12%]\r\ntests/test_config.py::TestSettingsPropertyPaths::test_documents_dir_property PASSED [ 18%]\r\ntests/test_document_processor.py::TestDocumentProcessor::test_process_file_extracts_correct_chunks FAILED [ 25%]\r\ntests/test_document_processor.py::TestDocumentProcessor::test_process_file_raises_duplicate_error_on_second_call FAILED [ 31%]\r\ntests/test_document_processor.py::TestDocumentProcessor::test_process_file_returns_valid_result FAILED [ 37%]\r\ntests/test_document_processor.py::TestDocumentProcessor::test_process_file_updates_db_status FAILED [ 43%]\r\ntests/test_integration.py::TestIntegration::test_chat_with_indexed_document PASSED [ 50%]\r\ntests/test_integration.py::TestIntegration::test_document_delete_not_found PASSED [ 56%]\r\ntests/test_integration.py::TestIntegration::test_document_delete_success PASSED [ 62%]\r\ntests/test_integration.py::TestIntegration::test_document_delete_without_existing_doc PASSED [ 68%]\r\ntests/test_rag_engine.py::RAGEngineTests::test_format_chunk_defaults_to_document_when_metadata_missing PASSED [ 75%]\r\ntests/test_vaults.py::TestVaultScopedRoutes::test_document_stats_filtered_by_vault PASSED [ 81%]\r\ntests/test_vaults.py::TestVaultScopedRoutes::test_document_stats_no_vault_returns_all PASSED [ 87%]\r\ntests/test_vaults.py::TestVaultScopedRoutes::test_list_documents_filtered_by_vault PASSED [ 93%]\r\ntests/test_vaults.py::TestVaultScopedRoutes::test_list_documents_no_vault_returns_all PASSED [100%]\r\n\r\n================================== FAILURES ===================================\r\n_______ TestDocumentProcessor.test_process_file_extracts_correct_chunks _______\r\n\r\nself = <app.services.document_processor.DocumentProcessor object at 0x0000021A7F532660>\r\nfile_path = 'C:\\\\Users\\\\zaxby\\\\AppData\\\\Local\\\\Temp\\\\tmpld63i8te\\\\test_schema.sql'\r\nfile_hash = 'ae45935a901ca9184433980a45d3ecf9a4f84b6b223a2d91b21a3b3c8377141b'\r\nconn = <sqlite3.Connection object at 0x0000021A7F3336A0>, vault_id = 1\r\nsource = 'upload', email_subject = None, email_sender = None\r\n\r\n    @with_retry(max_attempts=3, retry_exceptions=(sqlite3.Error,), raise_last_exception=True)\r\n    def _insert_or_get_file_record(\r\n        self,\r\n        file_path: str,\r\n        file_hash: str,\r\n        conn: sqlite3.Connection,\r\n        vault_id: int = 1,\r\n        source: str = 'upload',\r\n        email_subject: Optional[str] = None,\r\n        email_sender: Optional[str] = None,\r\n    ) -> int:\r\n        \"\"\"\r\n        Insert a new file record or update existing one, returning the file ID.\r\n    \r\n        Args:\r\n            file_path: Path to the file\r\n            file_hash: Computed hash of the file\r\n            conn: Database connection\r\n            vault_id: The vault ID for the file (defaults to 1)\r\n            source: Source of the file ('upload', 'scan', 'email')\r\n            email_subject: Subject line for email-sourced files\r\n            email_sender: Sender address for email-sourced files\r\n    \r\n        Returns:\r\n            The file ID (database row ID)\r\n    \r\n        Raises:\r\n            DocumentProcessingError: If database operations fail\r\n        \"\"\"\r\n        path = Path(file_path)\r\n        file_name = path.name\r\n        file_size = path.stat().st_size\r\n        file_type = path.suffix.lower() if path.suffix else None\r\n        now = datetime.now(UTC).isoformat()\r\n        path_str = str(file_path)\r\n    \r\n        try:\r\n            # Check if file record already exists by path\r\n            cursor = conn.execute(\r\n                \"SELECT id FROM files WHERE file_path = ?\",\r\n                (path_str,)\r\n            )\r\n            existing = cursor.fetchone()\r\n    \r\n            if existing:\r\n                # Validate existing row id\r\n                existing_id = existing['id']\r\n                if existing_id is None:\r\n                    raise DocumentProcessingError(\r\n                        f\"Existing file record for '{path_str}' has invalid NULL id\"\r\n                    )\r\n                file_id = int(existing_id)\r\n    \r\n                # Update existing record\r\n                conn.execute(\r\n                    \"\"\"UPDATE files\r\n                       SET file_hash = ?, file_size = ?, file_type = ?, vault_id = ?,\r\n                           source = ?, email_subject = ?, email_sender = ?,\r\n                           status = 'pending', error_message = NULL,\r\n                           modified_at = ?, processed_at = NULL\r\n                       WHERE id = ?\"\"\",\r\n                    (file_hash, file_size, file_type, vault_id, source, email_subject, email_sender, now, file_id)\r\n                )\r\n            else:\r\n                # Insert new record\r\n>               cursor = conn.execute(\r\n                    \"\"\"INSERT INTO files\r\n                       (file_path, file_name, file_hash, file_size, file_type, vault_id,\r\n                        source, email_subject, email_sender, status, created_at, modified_at)\r\n                       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', ?, ?)\"\"\",\r\n                    (path_str, file_name, file_hash, file_size, file_type, vault_id, source, email_subject, email_sender, now, now)\r\n                )\r\nE               sqlite3.OperationalError: table files has no column named source\r\n\r\napp\\services\\document_processor.py:227: OperationalError\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nself = <test_document_processor.TestDocumentProcessor testMethod=test_process_file_extracts_correct_chunks>\r\n\r\n    def test_process_file_extracts_correct_chunks(self):\r\n        \"\"\"Test that SQL file is correctly parsed into chunks.\"\"\"\r\n        # Process the SQL file\r\n>       result = asyncio.run(self.processor.process_file(self.sql_file_path))\r\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\ntests\\test_document_processor.py:173: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\nC:\\Program Files\\Python313\\Lib\\asyncio\\runners.py:194: in run\r\n    return runner.run(main)\r\n           ^^^^^^^^^^^^^^^^\r\nC:\\Program Files\\Python313\\Lib\\asyncio\\runners.py:118: in run\r\n    return self._loop.run_until_complete(task)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\nC:\\Program Files\\Python313\\Lib\\asyncio\\base_events.py:720: in run_until_complete\r\n    return future.result()\r\n           ^^^^^^^^^^^^^^^\r\napp\\services\\document_processor.py:400: in process_file\r\n    file_id = self._insert_or_get_file_record(\r\napp\\utils\\retry.py:64: in wrapper\r\n    return func(*args, **kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <app.services.document_processor.DocumentProcessor object at 0x0000021A7F532660>\r\nfile_path = 'C:\\\\Users\\\\zaxby\\\\AppData\\\\Local\\\\Temp\\\\tmpld63i8te\\\\test_schema.sql'\r\nfile_hash = 'ae45935a901ca9184433980a45d3ecf9a4f84b6b223a2d91b21a3b3c8377141b'\r\nconn = <sqlite3.Connection object at 0x0000021A7F3336A0>, vault_id = 1\r\nsource = 'upload', email_subject = None, email_sender = None\r\n\r\n    @with_retry(max_attempts=3, retry_exceptions=(sqlite3.Error,), raise_last_exception=True)\r\n    def _insert_or_get_file_record(\r\n        self,\r\n        file_path: str,\r\n        file_hash: str,\r\n        conn: sqlite3.Connection,\r\n        vault_id: int = 1,\r\n        source: str = 'upload',\r\n        email_subject: Optional[str] = None,\r\n        email_sender: Optional[str] = None,\r\n    ) -> int:\r\n        \"\"\"\r\n        Insert a new file record or update existing one, returning the file ID.\r\n    \r\n        Args:\r\n            file_path: Path to the file\r\n            file_hash: Computed hash of the file\r\n            conn: Database connection\r\n            vault_id: The vault ID for the file (defaults to 1)\r\n            source: Source of the file ('upload', 'scan', 'email')\r\n            email_subject: Subject line for email-sourced files\r\n            email_sender: Sender address for email-sourced files\r\n    \r\n        Returns:\r\n            The file ID (database row ID)\r\n    \r\n        Raises:\r\n            DocumentProcessingError: If database operations fail\r\n        \"\"\"\r\n        path = Path(file_path)\r\n        file_name = path.name\r\n        file_size = path.stat().st_size\r\n        file_type = path.suffix.lower() if path.suffix else None\r\n        now = datetime.now(UTC).isoformat()\r\n        path_str = str(file_path)\r\n    \r\n        try:\r\n            # Check if file record already exists by path\r\n            cursor = conn.execute(\r\n                \"SELECT id FROM files WHERE file_path = ?\",\r\n                (path_str,)\r\n            )\r\n            existing = cursor.fetchone()\r\n    \r\n            if existing:\r\n                # Validate existing row id\r\n                existing_id = existing['id']\r\n                if existing_id is None:\r\n                    raise DocumentProcessingError(\r\n                        f\"Existing file record for '{path_str}' has invalid NULL id\"\r\n                    )\r\n                file_id = int(existing_id)\r\n    \r\n                # Update existing record\r\n                conn.execute(\r\n                    \"\"\"UPDATE files\r\n                       SET file_hash = ?, file_size = ?, file_type = ?, vault_id = ?,\r\n                           source = ?, email_subject = ?, email_sender = ?,\r\n                           status = 'pending', error_message = NULL,\r\n                           modified_at = ?, processed_at = NULL\r\n                       WHERE id = ?\"\"\",\r\n                    (file_hash, file_size, file_type, vault_id, source, email_subject, email_sender, now, file_id)\r\n                )\r\n            else:\r\n                # Insert new record\r\n                cursor = conn.execute(\r\n                    \"\"\"INSERT INTO files\r\n                       (file_path, file_name, file_hash, file_size, file_type, vault_id,\r\n                        source, email_subject, email_sender, status, created_at, modified_at)\r\n                       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', ?, ?)\"\"\",\r\n                    (path_str, file_name, file_hash, file_size, file_type, vault_id, source, email_subject, email_sender, now, now)\r\n                )\r\n                lastrowid = cursor.lastrowid\r\n                if lastrowid is None:\r\n                    raise DocumentProcessingError(\r\n                        f\"Failed to insert file record for '{path_str}': lastrowid is None\"\r\n                    )\r\n                file_id = int(lastrowid)\r\n    \r\n            # Commit within the context of this method\r\n            conn.commit()\r\n            return file_id\r\n    \r\n        except sqlite3.Error as e:\r\n            # Rollback on error and wrap in DocumentProcessingError\r\n            conn.rollback()\r\n>           raise DocumentProcessingError(\r\n                f\"Database error while inserting/updating file record for '{path_str}': {str(e)}\"\r\n            ) from e\r\nE           app.services.document_processor.DocumentProcessingError: Database error while inserting/updating file record for 'C:\\Users\\zaxby\\AppData\\Local\\Temp\\tmpld63i8te\\test_schema.sql': table files has no column named source\r\n\r\napp\\services\\document_processor.py:248: DocumentProcessingError\r\n_ TestDocumentProcessor.test_process_file_raises_duplicate_error_on_second_call _\r\n\r\nself = <app.services.document_processor.DocumentProcessor object at 0x0000021A7F5E6710>\r\nfile_path = 'C:\\\\Users\\\\zaxby\\\\AppData\\\\Local\\\\Temp\\\\tmpzkapovzn\\\\test_schema.sql'\r\nfile_hash = 'ae45935a901ca9184433980a45d3ecf9a4f84b6b223a2d91b21a3b3c8377141b'\r\nconn = <sqlite3.Connection object at 0x0000021A7F600130>, vault_id = 1\r\nsource = 'upload', email_subject = None, email_sender = None\r\n\r\n    @with_retry(max_attempts=3, retry_exceptions=(sqlite3.Error,), raise_last_exception=True)\r\n    def _insert_or_get_file_record(\r\n        self,\r\n        file_path: str,\r\n        file_hash: str,\r\n        conn: sqlite3.Connection,\r\n        vault_id: int = 1,\r\n        source: str = 'upload',\r\n        email_subject: Optional[str] = None,\r\n        email_sender: Optional[str] = None,\r\n    ) -> int:\r\n        \"\"\"\r\n        Insert a new file record or update existing one, returning the file ID.\r\n    \r\n        Args:\r\n            file_path: Path to the file\r\n            file_hash: Computed hash of the file\r\n            conn: Database connection\r\n            vault_id: The vault ID for the file (defaults to 1)\r\n            source: Source of the file ('upload', 'scan', 'email')\r\n            email_subject: Subject line for email-sourced files\r\n            email_sender: Sender address for email-sourced files\r\n    \r\n        Returns:\r\n            The file ID (database row ID)\r\n    \r\n        Raises:\r\n            DocumentProcessingError: If database operations fail\r\n        \"\"\"\r\n        path = Path(file_path)\r\n        file_name = path.name\r\n        file_size = path.stat().st_size\r\n        file_type = path.suffix.lower() if path.suffix else None\r\n        now = datetime.now(UTC).isoformat()\r\n        path_str = str(file_path)\r\n    \r\n        try:\r\n            # Check if file record already exists by path\r\n            cursor = conn.execute(\r\n                \"SELECT id FROM files WHERE file_path = ?\",\r\n                (path_str,)\r\n            )\r\n            existing = cursor.fetchone()\r\n    \r\n            if existing:\r\n                # Validate existing row id\r\n                existing_id = existing['id']\r\n                if existing_id is None:\r\n                    raise DocumentProcessingError(\r\n                        f\"Existing file record for '{path_str}' has invalid NULL id\"\r\n                    )\r\n                file_id = int(existing_id)\r\n    \r\n                # Update existing record\r\n                conn.execute(\r\n                    \"\"\"UPDATE files\r\n                       SET file_hash = ?, file_size = ?, file_type = ?, vault_id = ?,\r\n                           source = ?, email_subject = ?, email_sender = ?,\r\n                           status = 'pending', error_message = NULL,\r\n                           modified_at = ?, processed_at = NULL\r\n                       WHERE id = ?\"\"\",\r\n                    (file_hash, file_size, file_type, vault_id, source, email_subject, email_sender, now, file_id)\r\n                )\r\n            else:\r\n                # Insert new record\r\n>               cursor = conn.execute(\r\n                    \"\"\"INSERT INTO files\r\n                       (file_path, file_name, file_hash, file_size, file_type, vault_id,\r\n                        source, email_subject, email_sender, status, created_at, modified_at)\r\n                       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', ?, ?)\"\"\",\r\n                    (path_str, file_name, file_hash, file_size, file_type, vault_id, source, email_subject, email_sender, now, now)\r\n                )\r\nE               sqlite3.OperationalError: table files has no column named source\r\n\r\napp\\services\\document_processor.py:227: OperationalError\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nself = <test_document_processor.TestDocumentProcessor testMethod=test_process_file_raises_duplicate_error_on_second_call>\r\n\r\n    def test_process_file_raises_duplicate_error_on_second_call(self):\r\n        \"\"\"Test that second call with same file raises DuplicateFileError.\"\"\"\r\n        # Process the SQL file first time\r\n>       asyncio.run(self.processor.process_file(self.sql_file_path))\r\n\r\ntests\\test_document_processor.py:164: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\nC:\\Program Files\\Python313\\Lib\\asyncio\\runners.py:194: in run\r\n    return runner.run(main)\r\n           ^^^^^^^^^^^^^^^^\r\nC:\\Program Files\\Python313\\Lib\\asyncio\\runners.py:118: in run\r\n    return self._loop.run_until_complete(task)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\nC:\\Program Files\\Python313\\Lib\\asyncio\\base_events.py:720: in run_until_complete\r\n    return future.result()\r\n           ^^^^^^^^^^^^^^^\r\napp\\services\\document_processor.py:400: in process_file\r\n    file_id = self._insert_or_get_file_record(\r\napp\\utils\\retry.py:64: in wrapper\r\n    return func(*args, **kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <app.services.document_processor.DocumentProcessor object at 0x0000021A7F5E6710>\r\nfile_path = 'C:\\\\Users\\\\zaxby\\\\AppData\\\\Local\\\\Temp\\\\tmpzkapovzn\\\\test_schema.sql'\r\nfile_hash = 'ae45935a901ca9184433980a45d3ecf9a4f84b6b223a2d91b21a3b3c8377141b'\r\nconn = <sqlite3.Connection object at 0x0000021A7F600130>, vault_id = 1\r\nsource = 'upload', email_subject = None, email_sender = None\r\n\r\n    @with_retry(max_attempts=3, retry_exceptions=(sqlite3.Error,), raise_last_exception=True)\r\n    def _insert_or_get_file_record(\r\n        self,\r\n        file_path: str,\r\n        file_hash: str,\r\n        conn: sqlite3.Connection,\r\n        vault_id: int = 1,\r\n        source: str = 'upload',\r\n        email_subject: Optional[str] = None,\r\n        email_sender: Optional[str] = None,\r\n    ) -> int:\r\n        \"\"\"\r\n        Insert a new file record or update existing one, returning the file ID.\r\n    \r\n        Args:\r\n            file_path: Path to the file\r\n            file_hash: Computed hash of the file\r\n            conn: Database connection\r\n            vault_id: The vault ID for the file (defaults to 1)\r\n            source: Source of the file ('upload', 'scan', 'email')\r\n            email_subject: Subject line for email-sourced files\r\n            email_sender: Sender address for email-sourced files\r\n    \r\n        Returns:\r\n            The file ID (database row ID)\r\n    \r\n        Raises:\r\n            DocumentProcessingError: If database operations fail\r\n        \"\"\"\r\n        path = Path(file_path)\r\n        file_name = path.name\r\n        file_size = path.stat().st_size\r\n        file_type = path.suffix.lower() if path.suffix else None\r\n        now = datetime.now(UTC).isoformat()\r\n        path_str = str(file_path)\r\n    \r\n        try:\r\n            # Check if file record already exists by path\r\n            cursor = conn.execute(\r\n                \"SELECT id FROM files WHERE file_path = ?\",\r\n                (path_str,)\r\n            )\r\n            existing = cursor.fetchone()\r\n    \r\n            if existing:\r\n                # Validate existing row id\r\n                existing_id = existing['id']\r\n                if existing_id is None:\r\n                    raise DocumentProcessingError(\r\n                        f\"Existing file record for '{path_str}' has invalid NULL id\"\r\n                    )\r\n                file_id = int(existing_id)\r\n    \r\n                # Update existing record\r\n                conn.execute(\r\n                    \"\"\"UPDATE files\r\n                       SET file_hash = ?, file_size = ?, file_type = ?, vault_id = ?,\r\n                           source = ?, email_subject = ?, email_sender = ?,\r\n                           status = 'pending', error_message = NULL,\r\n                           modified_at = ?, processed_at = NULL\r\n                       WHERE id = ?\"\"\",\r\n                    (file_hash, file_size, file_type, vault_id, source, email_subject, email_sender, now, file_id)\r\n                )\r\n            else:\r\n                # Insert new record\r\n                cursor = conn.execute(\r\n                    \"\"\"INSERT INTO files\r\n                       (file_path, file_name, file_hash, file_size, file_type, vault_id,\r\n                        source, email_subject, email_sender, status, created_at, modified_at)\r\n                       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', ?, ?)\"\"\",\r\n                    (path_str, file_name, file_hash, file_size, file_type, vault_id, source, email_subject, email_sender, now, now)\r\n                )\r\n                lastrowid = cursor.lastrowid\r\n                if lastrowid is None:\r\n                    raise DocumentProcessingError(\r\n                        f\"Failed to insert file record for '{path_str}': lastrowid is None\"\r\n                    )\r\n                file_id = int(lastrowid)\r\n    \r\n            # Commit within the context of this method\r\n            conn.commit()\r\n            return file_id\r\n    \r\n        except sqlite3.Error as e:\r\n            # Rollback on error and wrap in DocumentProcessingError\r\n            conn.rollback()\r\n>           raise DocumentProcessingError(\r\n                f\"Database error while inserting/updating file record for '{path_str}': {str(e)}\"\r\n            ) from e\r\nE           app.services.document_processor.DocumentProcessingError: Database error while inserting/updating file record for 'C:\\Users\\zaxby\\AppData\\Local\\Temp\\tmpzkapovzn\\test_schema.sql': table files has no column named source\r\n\r\napp\\services\\document_processor.py:248: DocumentProcessingError\r\n________ TestDocumentProcessor.test_process_file_returns_valid_result _________\r\n\r\nself = <app.services.document_processor.DocumentProcessor object at 0x0000021A7F5E5590>\r\nfile_path = 'C:\\\\Users\\\\zaxby\\\\AppData\\\\Local\\\\Temp\\\\tmpw8hrsktu\\\\test_schema.sql'\r\nfile_hash = 'ae45935a901ca9184433980a45d3ecf9a4f84b6b223a2d91b21a3b3c8377141b'\r\nconn = <sqlite3.Connection object at 0x0000021A7F600220>, vault_id = 1\r\nsource = 'upload', email_subject = None, email_sender = None\r\n\r\n    @with_retry(max_attempts=3, retry_exceptions=(sqlite3.Error,), raise_last_exception=True)\r\n    def _insert_or_get_file_record(\r\n        self,\r\n        file_path: str,\r\n        file_hash: str,\r\n        conn: sqlite3.Connection,\r\n        vault_id: int = 1,\r\n        source: str = 'upload',\r\n        email_subject: Optional[str] = None,\r\n        email_sender: Optional[str] = None,\r\n    ) -> int:\r\n        \"\"\"\r\n        Insert a new file record or update existing one, returning the file ID.\r\n    \r\n        Args:\r\n            file_path: Path to the file\r\n            file_hash: Computed hash of the file\r\n            conn: Database connection\r\n            vault_id: The vault ID for the file (defaults to 1)\r\n            source: Source of the file ('upload', 'scan', 'email')\r\n            email_subject: Subject line for email-sourced files\r\n            email_sender: Sender address for email-sourced files\r\n    \r\n        Returns:\r\n            The file ID (database row ID)\r\n    \r\n        Raises:\r\n            DocumentProcessingError: If database operations fail\r\n        \"\"\"\r\n        path = Path(file_path)\r\n        file_name = path.name\r\n        file_size = path.stat().st_size\r\n        file_type = path.suffix.lower() if path.suffix else None\r\n        now = datetime.now(UTC).isoformat()\r\n        path_str = str(file_path)\r\n    \r\n        try:\r\n            # Check if file record already exists by path\r\n            cursor = conn.execute(\r\n                \"SELECT id FROM files WHERE file_path = ?\",\r\n                (path_str,)\r\n            )\r\n            existing = cursor.fetchone()\r\n    \r\n            if existing:\r\n                # Validate existing row id\r\n                existing_id = existing['id']\r\n                if existing_id is None:\r\n                    raise DocumentProcessingError(\r\n                        f\"Existing file record for '{path_str}' has invalid NULL id\"\r\n                    )\r\n                file_id = int(existing_id)\r\n    \r\n                # Update existing record\r\n                conn.execute(\r\n                    \"\"\"UPDATE files\r\n                       SET file_hash = ?, file_size = ?, file_type = ?, vault_id = ?,\r\n                           source = ?, email_subject = ?, email_sender = ?,\r\n                           status = 'pending', error_message = NULL,\r\n                           modified_at = ?, processed_at = NULL\r\n                       WHERE id = ?\"\"\",\r\n                    (file_hash, file_size, file_type, vault_id, source, email_subject, email_sender, now, file_id)\r\n                )\r\n            else:\r\n                # Insert new record\r\n>               cursor = conn.execute(\r\n                    \"\"\"INSERT INTO files\r\n                       (file_path, file_name, file_hash, file_size, file_type, vault_id,\r\n                        source, email_subject, email_sender, status, created_at, modified_at)\r\n                       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', ?, ?)\"\"\",\r\n                    (path_str, file_name, file_hash, file_size, file_type, vault_id, source, email_subject, email_sender, now, now)\r\n                )\r\nE               sqlite3.OperationalError: table files has no column named source\r\n\r\napp\\services\\document_processor.py:227: OperationalError\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nself = <test_document_processor.TestDocumentProcessor testMethod=test_process_file_returns_valid_result>\r\n\r\n    def test_process_file_returns_valid_result(self):\r\n        \"\"\"Test that process_file returns valid ProcessedDocument with SQL file.\"\"\"\r\n        # Process the SQL file\r\n>       result = asyncio.run(self.processor.process_file(self.sql_file_path))\r\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\ntests\\test_document_processor.py:126: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\nC:\\Program Files\\Python313\\Lib\\asyncio\\runners.py:194: in run\r\n    return runner.run(main)\r\n           ^^^^^^^^^^^^^^^^\r\nC:\\Program Files\\Python313\\Lib\\asyncio\\runners.py:118: in run\r\n    return self._loop.run_until_complete(task)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\nC:\\Program Files\\Python313\\Lib\\asyncio\\base_events.py:720: in run_until_complete\r\n    return future.result()\r\n           ^^^^^^^^^^^^^^^\r\napp\\services\\document_processor.py:400: in process_file\r\n    file_id = self._insert_or_get_file_record(\r\napp\\utils\\retry.py:64: in wrapper\r\n    return func(*args, **kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <app.services.document_processor.DocumentProcessor object at 0x0000021A7F5E5590>\r\nfile_path = 'C:\\\\Users\\\\zaxby\\\\AppData\\\\Local\\\\Temp\\\\tmpw8hrsktu\\\\test_schema.sql'\r\nfile_hash = 'ae45935a901ca9184433980a45d3ecf9a4f84b6b223a2d91b21a3b3c8377141b'\r\nconn = <sqlite3.Connection object at 0x0000021A7F600220>, vault_id = 1\r\nsource = 'upload', email_subject = None, email_sender = None\r\n\r\n    @with_retry(max_attempts=3, retry_exceptions=(sqlite3.Error,), raise_last_exception=True)\r\n    def _insert_or_get_file_record(\r\n        self,\r\n        file_path: str,\r\n        file_hash: str,\r\n        conn: sqlite3.Connection,\r\n        vault_id: int = 1,\r\n        source: str = 'upload',\r\n        email_subject: Optional[str] = None,\r\n        email_sender: Optional[str] = None,\r\n    ) -> int:\r\n        \"\"\"\r\n        Insert a new file record or update existing one, returning the file ID.\r\n    \r\n        Args:\r\n            file_path: Path to the file\r\n            file_hash: Computed hash of the file\r\n            conn: Database connection\r\n            vault_id: The vault ID for the file (defaults to 1)\r\n            source: Source of the file ('upload', 'scan', 'email')\r\n            email_subject: Subject line for email-sourced files\r\n            email_sender: Sender address for email-sourced files\r\n    \r\n        Returns:\r\n            The file ID (database row ID)\r\n    \r\n        Raises:\r\n            DocumentProcessingError: If database operations fail\r\n        \"\"\"\r\n        path = Path(file_path)\r\n        file_name = path.name\r\n        file_size = path.stat().st_size\r\n        file_type = path.suffix.lower() if path.suffix else None\r\n        now = datetime.now(UTC).isoformat()\r\n        path_str = str(file_path)\r\n    \r\n        try:\r\n            # Check if file record already exists by path\r\n            cursor = conn.execute(\r\n                \"SELECT id FROM files WHERE file_path = ?\",\r\n                (path_str,)\r\n            )\r\n            existing = cursor.fetchone()\r\n    \r\n            if existing:\r\n                # Validate existing row id\r\n                existing_id = existing['id']\r\n                if existing_id is None:\r\n                    raise DocumentProcessingError(\r\n                        f\"Existing file record for '{path_str}' has invalid NULL id\"\r\n                    )\r\n                file_id = int(existing_id)\r\n    \r\n                # Update existing record\r\n                conn.execute(\r\n                    \"\"\"UPDATE files\r\n                       SET file_hash = ?, file_size = ?, file_type = ?, vault_id = ?,\r\n                           source = ?, email_subject = ?, email_sender = ?,\r\n                           status = 'pending', error_message = NULL,\r\n                           modified_at = ?, processed_at = NULL\r\n                       WHERE id = ?\"\"\",\r\n                    (file_hash, file_size, file_type, vault_id, source, email_subject, email_sender, now, file_id)\r\n                )\r\n            else:\r\n                # Insert new record\r\n                cursor = conn.execute(\r\n                    \"\"\"INSERT INTO files\r\n                       (file_path, file_name, file_hash, file_size, file_type, vault_id,\r\n                        source, email_subject, email_sender, status, created_at, modified_at)\r\n                       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', ?, ?)\"\"\",\r\n                    (path_str, file_name, file_hash, file_size, file_type, vault_id, source, email_subject, email_sender, now, now)\r\n                )\r\n                lastrowid = cursor.lastrowid\r\n                if lastrowid is None:\r\n                    raise DocumentProcessingError(\r\n                        f\"Failed to insert file record for '{path_str}': lastrowid is None\"\r\n                    )\r\n                file_id = int(lastrowid)\r\n    \r\n            # Commit within the context of this method\r\n            conn.commit()\r\n            return file_id\r\n    \r\n        except sqlite3.Error as e:\r\n            # Rollback on error and wrap in DocumentProcessingError\r\n            conn.rollback()\r\n>           raise DocumentProcessingError(\r\n                f\"Database error while inserting/updating file record for '{path_str}': {str(e)}\"\r\n            ) from e\r\nE           app.services.document_processor.DocumentProcessingError: Database error while inserting/updating file record for 'C:\\Users\\zaxby\\AppData\\Local\\Temp\\tmpw8hrsktu\\test_schema.sql': table files has no column named source\r\n\r\napp\\services\\document_processor.py:248: DocumentProcessingError\r\n__________ TestDocumentProcessor.test_process_file_updates_db_status __________\r\n\r\nself = <app.services.document_processor.DocumentProcessor object at 0x0000021A7F5A9E00>\r\nfile_path = 'C:\\\\Users\\\\zaxby\\\\AppData\\\\Local\\\\Temp\\\\tmprxs687ad\\\\test_schema.sql'\r\nfile_hash = 'ae45935a901ca9184433980a45d3ecf9a4f84b6b223a2d91b21a3b3c8377141b'\r\nconn = <sqlite3.Connection object at 0x0000021A7F3332E0>, vault_id = 1\r\nsource = 'upload', email_subject = None, email_sender = None\r\n\r\n    @with_retry(max_attempts=3, retry_exceptions=(sqlite3.Error,), raise_last_exception=True)\r\n    def _insert_or_get_file_record(\r\n        self,\r\n        file_path: str,\r\n        file_hash: str,\r\n        conn: sqlite3.Connection,\r\n        vault_id: int = 1,\r\n        source: str = 'upload',\r\n        email_subject: Optional[str] = None,\r\n        email_sender: Optional[str] = None,\r\n    ) -> int:\r\n        \"\"\"\r\n        Insert a new file record or update existing one, returning the file ID.\r\n    \r\n        Args:\r\n            file_path: Path to the file\r\n            file_hash: Computed hash of the file\r\n            conn: Database connection\r\n            vault_id: The vault ID for the file (defaults to 1)\r\n            source: Source of the file ('upload', 'scan', 'email')\r\n            email_subject: Subject line for email-sourced files\r\n            email_sender: Sender address for email-sourced files\r\n    \r\n        Returns:\r\n            The file ID (database row ID)\r\n    \r\n        Raises:\r\n            DocumentProcessingError: If database operations fail\r\n        \"\"\"\r\n        path = Path(file_path)\r\n        file_name = path.name\r\n        file_size = path.stat().st_size\r\n        file_type = path.suffix.lower() if path.suffix else None\r\n        now = datetime.now(UTC).isoformat()\r\n        path_str = str(file_path)\r\n    \r\n        try:\r\n            # Check if file record already exists by path\r\n            cursor = conn.execute(\r\n                \"SELECT id FROM files WHERE file_path = ?\",\r\n                (path_str,)\r\n            )\r\n            existing = cursor.fetchone()\r\n    \r\n            if existing:\r\n                # Validate existing row id\r\n                existing_id = existing['id']\r\n                if existing_id is None:\r\n                    raise DocumentProcessingError(\r\n                        f\"Existing file record for '{path_str}' has invalid NULL id\"\r\n                    )\r\n                file_id = int(existing_id)\r\n    \r\n                # Update existing record\r\n                conn.execute(\r\n                    \"\"\"UPDATE files\r\n                       SET file_hash = ?, file_size = ?, file_type = ?, vault_id = ?,\r\n                           source = ?, email_subject = ?, email_sender = ?,\r\n                           status = 'pending', error_message = NULL,\r\n                           modified_at = ?, processed_at = NULL\r\n                       WHERE id = ?\"\"\",\r\n                    (file_hash, file_size, file_type, vault_id, source, email_subject, email_sender, now, file_id)\r\n                )\r\n            else:\r\n                # Insert new record\r\n>               cursor = conn.execute(\r\n                    \"\"\"INSERT INTO files\r\n                       (file_path, file_name, file_hash, file_size, file_type, vault_id,\r\n                        source, email_subject, email_sender, status, created_at, modified_at)\r\n                       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', ?, ?)\"\"\",\r\n                    (path_str, file_name, file_hash, file_size, file_type, vault_id, source, email_subject, email_sender, now, now)\r\n                )\r\nE               sqlite3.OperationalError: table files has no column named source\r\n\r\napp\\services\\document_processor.py:227: OperationalError\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nself = <test_document_processor.TestDocumentProcessor testMethod=test_process_file_updates_db_status>\r\n\r\n    def test_process_file_updates_db_status(self):\r\n        \"\"\"Test that process_file updates DB status to indexed with chunk_count.\"\"\"\r\n        # Process the SQL file\r\n>       result = asyncio.run(self.processor.process_file(self.sql_file_path))\r\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\ntests\\test_document_processor.py:142: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\nC:\\Program Files\\Python313\\Lib\\asyncio\\runners.py:194: in run\r\n    return runner.run(main)\r\n           ^^^^^^^^^^^^^^^^\r\nC:\\Program Files\\Python313\\Lib\\asyncio\\runners.py:118: in run\r\n    return self._loop.run_until_complete(task)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\nC:\\Program Files\\Python313\\Lib\\asyncio\\base_events.py:720: in run_until_complete\r\n    return future.result()\r\n           ^^^^^^^^^^^^^^^\r\napp\\services\\document_processor.py:400: in process_file\r\n    file_id = self._insert_or_get_file_record(\r\napp\\utils\\retry.py:64: in wrapper\r\n    return func(*args, **kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <app.services.document_processor.DocumentProcessor object at 0x0000021A7F5A9E00>\r\nfile_path = 'C:\\\\Users\\\\zaxby\\\\AppData\\\\Local\\\\Temp\\\\tmprxs687ad\\\\test_schema.sql'\r\nfile_hash = 'ae45935a901ca9184433980a45d3ecf9a4f84b6b223a2d91b21a3b3c8377141b'\r\nconn = <sqlite3.Connection object at 0x0000021A7F3332E0>, vault_id = 1\r\nsource = 'upload', email_subject = None, email_sender = None\r\n\r\n    @with_retry(max_attempts=3, retry_exceptions=(sqlite3.Error,), raise_last_exception=True)\r\n    def _insert_or_get_file_record(\r\n        self,\r\n        file_path: str,\r\n        file_hash: str,\r\n        conn: sqlite3.Connection,\r\n        vault_id: int = 1,\r\n        source: str = 'upload',\r\n        email_subject: Optional[str] = None,\r\n        email_sender: Optional[str] = None,\r\n    ) -> int:\r\n        \"\"\"\r\n        Insert a new file record or update existing one, returning the file ID.\r\n    \r\n        Args:\r\n            file_path: Path to the file\r\n            file_hash: Computed hash of the file\r\n            conn: Database connection\r\n            vault_id: The vault ID for the file (defaults to 1)\r\n            source: Source of the file ('upload', 'scan', 'email')\r\n            email_subject: Subject line for email-sourced files\r\n            email_sender: Sender address for email-sourced files\r\n    \r\n        Returns:\r\n            The file ID (database row ID)\r\n    \r\n        Raises:\r\n            DocumentProcessingError: If database operations fail\r\n        \"\"\"\r\n        path = Path(file_path)\r\n        file_name = path.name\r\n        file_size = path.stat().st_size\r\n        file_type = path.suffix.lower() if path.suffix else None\r\n        now = datetime.now(UTC).isoformat()\r\n        path_str = str(file_path)\r\n    \r\n        try:\r\n            # Check if file record already exists by path\r\n            cursor = conn.execute(\r\n                \"SELECT id FROM files WHERE file_path = ?\",\r\n                (path_str,)\r\n            )\r\n            existing = cursor.fetchone()\r\n    \r\n            if existing:\r\n                # Validate existing row id\r\n                existing_id = existing['id']\r\n                if existing_id is None:\r\n                    raise DocumentProcessingError(\r\n                        f\"Existing file record for '{path_str}' has invalid NULL id\"\r\n                    )\r\n                file_id = int(existing_id)\r\n    \r\n                # Update existing record\r\n                conn.execute(\r\n                    \"\"\"UPDATE files\r\n                       SET file_hash = ?, file_size = ?, file_type = ?, vault_id = ?,\r\n                           source = ?, email_subject = ?, email_sender = ?,\r\n                           status = 'pending', error_message = NULL,\r\n                           modified_at = ?, processed_at = NULL\r\n                       WHERE id = ?\"\"\",\r\n                    (file_hash, file_size, file_type, vault_id, source, email_subject, email_sender, now, file_id)\r\n                )\r\n            else:\r\n                # Insert new record\r\n                cursor = conn.execute(\r\n                    \"\"\"INSERT INTO files\r\n                       (file_path, file_name, file_hash, file_size, file_type, vault_id,\r\n                        source, email_subject, email_sender, status, created_at, modified_at)\r\n                       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', ?, ?)\"\"\",\r\n                    (path_str, file_name, file_hash, file_size, file_type, vault_id, source, email_subject, email_sender, now, now)\r\n                )\r\n                lastrowid = cursor.lastrowid\r\n                if lastrowid is None:\r\n                    raise DocumentProcessingError(\r\n                        f\"Failed to insert file record for '{path_str}': lastrowid is None\"\r\n                    )\r\n                file_id = int(lastrowid)\r\n    \r\n            # Commit within the context of this method\r\n            conn.commit()\r\n            return file_id\r\n    \r\n        except sqlite3.Error as e:\r\n            # Rollback on error and wrap in DocumentProcessingError\r\n            conn.rollback()\r\n>           raise DocumentProcessingError(\r\n                f\"Database error while inserting/updating file record for '{path_str}': {str(e)}\"\r\n            ) from e\r\nE           app.services.document_processor.DocumentProcessingError: Database error while inserting/updating file record for 'C:\\Users\\zaxby\\AppData\\Local\\Temp\\tmprxs687ad\\test_schema.sql': table files has no column named source\r\n\r\napp\\services\\document_processor.py:248: DocumentProcessingError\r\n=========================== short test summary info ===========================\r\nFAILED tests/test_document_processor.py::TestDocumentProcessor::test_process_file_extracts_correct_chunks\r\nFAILED tests/test_document_processor.py::TestDocumentProcessor::test_process_file_raises_duplicate_error_on_second_call\r\nFAILED tests/test_document_processor.py::TestDocumentProcessor::test_process_file_returns_valid_result\r\nFAILED tests/test_document_processor.py::TestDocumentProcessor::test_process_file_updates_db_status\r\n================ 4 failed, 12 passed, 155 deselected in 1.50s =================\r\n","timestamp":1771494189285,"originalBytes":41007}