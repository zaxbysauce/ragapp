{"id":"S563","summaryText":"[SUMMARY S563] 50.3 KB | code | 1099 lines\n<path>C:\\opencode\\RAGAPPv2\\backend\\tests\\test_embeddings_adversarial.py</path>\n<type>file</type>\n<content>1: \"\"\"\n2: Adversarial tests for embedding service single-input overflow fallback.\n3: Tests attack vectors: malformed overflow errors, tiny/empty split boundaries,\nâ†’ Use /swarm retrieve S563 for full content","fullOutput":"<path>C:\\opencode\\RAGAPPv2\\backend\\tests\\test_embeddings_adversarial.py</path>\n<type>file</type>\n<content>1: \"\"\"\n2: Adversarial tests for embedding service single-input overflow fallback.\n3: Tests attack vectors: malformed overflow errors, tiny/empty split boundaries,\n4: repeated overflow recursion pressure, unexpected response shapes.\n5: \n6: CONSTRAINT: Testing only - no code edits.\n7: \"\"\"\n8: import sys\n9: import os\n10: \n11: # Add parent directory to path for imports\n12: sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))\n13: \n14: # Stub missing optional dependencies\n15: try:\n16:     import lancedb\n17: except ImportError:\n18:     import types\n19:     sys.modules['lancedb'] = types.ModuleType('lancedb')\n20: \n21: try:\n22:     import pyarrow\n23: except ImportError:\n24:     import types\n25:     sys.modules['pyarrow'] = types.ModuleType('pyarrow')\n26: \n27: import pytest\n28: from unittest.mock import AsyncMock, patch, MagicMock\n29: from httpx import HTTPError\n30: \n31: from app.services.embeddings import EmbeddingService, EmbeddingError\n32: \n33: \n34: # ==============================================================================\n35: # ATTACK VECTOR 1: MALFORMED OVERFLOW ERRORS\n36: # ==============================================================================\n37: \n38: class TestMalformedOverflowErrors:\n39:     \"\"\"Tests for malformed, partial, or ambiguous overflow error patterns.\"\"\"\n40: \n41:     @pytest.fixture(autouse=True)\n42:     def setup(self):\n43:         \"\"\"Set up test fixtures.\"\"\"\n44:         self.mock_settings_patcher = patch('app.services.embeddings.settings')\n45:         self.mock_settings = self.mock_settings_patcher.start()\n46:         self._configure_settings()\n47: \n48:     def _configure_settings(self):\n49:         \"\"\"Configure mock settings.\"\"\"\n50:         self.mock_settings.ollama_embedding_url = \"http://localhost:11434/api/embeddings\"\n51:         self.mock_settings.embedding_model = \"nomic-embed-text\"\n52:         self.mock_settings.embedding_doc_prefix = \"\"\n53:         self.mock_settings.embedding_query_prefix = \"\"\n54:         self.mock_settings.embedding_batch_size = 512\n55:         self.mock_settings.embedding_batch_max_retries = 3\n56:         self.mock_settings.embedding_batch_min_sub_size = 1\n57:         self.mock_settings.chunk_size_chars = 1200\n58:         self.mock_settings.chunk_overlap_chars = 120\n59: \n60:     @pytest.fixture(autouse=True)\n61:     def teardown(self):\n62:         \"\"\"Tear down test fixtures.\"\"\"\n63:         yield\n64:         self.mock_settings_patcher.stop()\n65: \n66:     def _create_overflow_response_500(self, error_text: str):\n67:         \"\"\"Create a mock 500 response with custom error text.\"\"\"\n68:         response = MagicMock()\n69:         response.status_code = 500\n70:         response.text = error_text\n71:         response.json.side_effect = ValueError(\"Not JSON\")\n72:         return response\n73: \n74:     @pytest.mark.asyncio\n75:     async def test_malformed_overflow_partial_pattern_input_only(self):\n76:         \"\"\"ATTACK: Error message with only 'input (' but no 'tokens) is too large'.\"\"\"\n77:         service = EmbeddingService()\n78:         texts = [\"Test text \" * 50]  # Long enough for potential split\n79: \n80:         mock_client = MagicMock()\n81:         # Malformed: has \"input (\" but missing the full pattern\n82:         response = self._create_overflow_response_500(\"input ( something went wrong but no token message\")\n83: \n84:         call_count = [0]\n85:         async def mock_post(*args, **kwargs):\n86:             call_count[0] += 1\n87:             return response\n88: \n89:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n90:             mock_client_class.return_value.__aenter__.return_value = mock_client\n91:             mock_client.post = mock_post\n92: \n93:             # Should raise EmbeddingError (not overflow-retry) since pattern doesn't match\n94:             with pytest.raises(EmbeddingError) as context:\n95:                 await service.embed_batch(texts, batch_size=1)\n96: \n97:             # Should NOT be a single-input overflow message since pattern didn't match\n98:             error_msg = str(context.value).lower()\n99:             assert \"single input\" not in error_msg or \"too short to split\" not in error_msg\n100: \n101:     @pytest.mark.asyncio\n102:     async def test_malformed_overflow_partial_pattern_tokens_only(self):\n103:         \"\"\"ATTACK: Error message with 'tokens) is too large' but no 'input ('.\"\"\"\n104:         service = EmbeddingService()\n105:         texts = [\"Test text \" * 50]\n106: \n107:         mock_client = MagicMock()\n108:         # Malformed: has end of pattern but not start\n109:         response = self._create_overflow_response_500(\"tokens) is too large but no input prefix\")\n110: \n111:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n112:             mock_client_class.return_value.__aenter__.return_value = mock_client\n113:             mock_client.post = AsyncMock(return_value=response)\n114: \n115:             with pytest.raises(EmbeddingError) as context:\n116:                 await service.embed_batch(texts, batch_size=1)\n117: \n118:             # Should fail with generic error, not overflow recovery\n119:             assert \"500\" in str(context.value)\n120: \n121:     @pytest.mark.asyncio\n122:     async def test_malformed_overflow_unicode_injection(self):\n123:         \"\"\"ATTACK: Overflow error with unicode/invisible characters trying to bypass detection.\"\"\"\n124:         service = EmbeddingService()\n125:         texts = [\"Test text \" * 50]\n126: \n127:         mock_client = MagicMock()\n128:         # Malformed: unicode characters interspersed in pattern\n129:         # Using raw string and explicit unicode for zero-width space\n130:         unicode_error = \"inp\\u200but (4096 tok\\u200bens) is too la\\\\urge to process\"\n131:         response = self._create_overflow_response_500(unicode_error)\n132: \n133:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n134:             mock_client_class.return_value.__aenter__.return_value = mock_client\n135:             mock_client.post = AsyncMock(return_value=response)\n136: \n137:             with pytest.raises(EmbeddingError):\n138:                 await service.embed_batch(texts, batch_size=1)\n139: \n140:     @pytest.mark.asyncio\n141:     async def test_malformed_overflow_null_bytes_in_error(self):\n142:         \"\"\"ATTACK: Overflow error with null bytes in message.\"\"\"\n143:         service = EmbeddingService()\n144:         texts = [\"Test text \" * 50]\n145: \n146:         mock_client = MagicMock()\n147:         # Malformed: null bytes in error message\n148:         response = self._create_overflow_response_500(\"input\\x00(4096 tokens)\\x00is too large\")\n149: \n150:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n151:             mock_client_class.return_value.__aenter__.return_value = mock_client\n152:             mock_client.post = AsyncMock(return_value=response)\n153: \n154:             with pytest.raises(EmbeddingError):\n155:                 await service.embed_batch(texts, batch_size=1)\n156: \n157:     @pytest.mark.asyncio\n158:     async def test_malformed_overflow_almost_matches_batch_size_pattern(self):\n159:         \"\"\"ATTACK: Error message almost matches 'batch size too small' pattern.\"\"\"\n160:         service = EmbeddingService()\n161:         texts = [\"Test text \" * 50]\n162: \n163:         mock_client = MagicMock()\n164:         # Malformed: close but not exact\n165:         response = self._create_overflow_response_500(\"batch size is too smallllll\")  # Extra 'l'\n166: \n167:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n168:             mock_client_class.return_value.__aenter__.return_value = mock_client\n169:             mock_client.post = AsyncMock(return_value=response)\n170: \n171:             with pytest.raises(EmbeddingError):\n172:                 await service.embed_batch(texts, batch_size=1)\n173: \n174: \n175: # ==============================================================================\n176: # ATTACK VECTOR 2: TINY/EMPTY SPLIT BOUNDARIES\n177: # ==============================================================================\n178: \n179: class TestTinyEmptySplitBoundaries:\n180:     \"\"\"Tests for edge cases at MIN_SPLIT_CHARS boundary and empty split results.\"\"\"\n181: \n182:     @pytest.fixture(autouse=True)\n183:     def setup(self):\n184:         self.mock_settings_patcher = patch('app.services.embeddings.settings')\n185:         self.mock_settings = self.mock_settings_patcher.start()\n186:         self._configure_settings()\n187: \n188:     def _configure_settings(self):\n189:         self.mock_settings.ollama_embedding_url = \"http://localhost:11434/api/embeddings\"\n190:         self.mock_settings.embedding_model = \"nomic-embed-text\"\n191:         self.mock_settings.embedding_doc_prefix = \"\"\n192:         self.mock_settings.embedding_query_prefix = \"\"\n193:         self.mock_settings.embedding_batch_size = 512\n194:         self.mock_settings.embedding_batch_max_retries = 3\n195:         self.mock_settings.embedding_batch_min_sub_size = 1\n196:         self.mock_settings.chunk_size_chars = 1200\n197:         self.mock_settings.chunk_overlap_chars = 120\n198: \n199:     @pytest.fixture(autouse=True)\n200:     def teardown(self):\n201:         yield\n202:         self.mock_settings_patcher.stop()\n203: \n204:     def _create_overflow_error(self, message=\"input (4096 tokens) is too large to process, current batch size: 1024\"):\n205:         \"\"\"Create an HTTPError simulating llama.cpp token overflow.\"\"\"\n206:         return HTTPError(message)\n207: \n208:     @pytest.mark.asyncio\n209:     async def test_text_exactly_at_min_split_chars_boundary(self):\n210:         \"\"\"ATTACK: Text exactly at MIN_SPLIT_CHARS (200 chars) - boundary condition.\"\"\"\n211:         service = EmbeddingService()\n212:         \n213:         # Create text exactly at 200 characters\n214:         boundary_text = \"a\" * service.MIN_SPLIT_CHARS\n215:         assert len(boundary_text) == service.MIN_SPLIT_CHARS\n216:         \n217:         texts = [boundary_text]\n218:         mock_client = MagicMock()\n219: \n220:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n221:             mock_client_class.return_value.__aenter__.return_value = mock_client\n222:             mock_client.post = AsyncMock(side_effect=self._create_overflow_error())\n223: \n224:             with pytest.raises(EmbeddingError) as context:\n225:                 await service.embed_batch(texts, batch_size=1)\n226: \n227:             # Text at exact boundary is >= MIN_SPLIT_CHARS, should attempt split\n228:             error_msg = str(context.value).lower()\n229:             # At boundary, split will be attempted\n230:             assert \"single input\" in error_msg or \"exhausted\" in error_msg or \"too short\" in error_msg\n231: \n232:     @pytest.mark.asyncio\n233:     async def test_text_one_char_below_min_split_chars_boundary(self):\n234:         \"\"\"ATTACK: Text one character below MIN_SPLIT_CHARS (199 chars).\"\"\"\n235:         service = EmbeddingService()\n236:         \n237:         # Create text exactly at 199 characters (one below threshold)\n238:         below_boundary_text = \"a\" * (service.MIN_SPLIT_CHARS - 1)\n239:         assert len(below_boundary_text) == service.MIN_SPLIT_CHARS - 1\n240:         \n241:         texts = [below_boundary_text]\n242:         mock_client = MagicMock()\n243: \n244:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n245:             mock_client_class.return_value.__aenter__.return_value = mock_client\n246:             mock_client.post = AsyncMock(side_effect=self._create_overflow_error())\n247: \n248:             with pytest.raises(EmbeddingError) as context:\n249:                 await service.embed_batch(texts, batch_size=1)\n250: \n251:             # Should fail with actionable message about being too short\n252:             error_msg = str(context.value).lower()\n253:             assert \"too short to split\" in error_msg or str(service.MIN_SPLIT_CHARS) in error_msg\n254: \n255:     @pytest.mark.asyncio\n256:     async def test_text_is_all_newlines_at_boundary(self):\n257:         \"\"\"ATTACK: Text at boundary but composed of only newlines.\"\"\"\n258:         service = EmbeddingService()\n259:         \n260:         # Text with only newlines at boundary\n261:         newline_text = \"\\n\" * service.MIN_SPLIT_CHARS\n262:         texts = [newline_text]\n263:         mock_client = MagicMock()\n264: \n265:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n266:             mock_client_class.return_value.__aenter__.return_value = mock_client\n267:             mock_client.post = AsyncMock(side_effect=self._create_overflow_error())\n268: \n269:             with pytest.raises(EmbeddingError) as context:\n270:                 await service.embed_batch(texts, batch_size=1)\n271: \n272:             # Should handle gracefully\n273:             assert context.value is not None\n274: \n275:     @pytest.mark.asyncio\n276:     async def test_text_is_all_spaces_at_boundary(self):\n277:         \"\"\"ATTACK: Text at boundary but composed of only spaces.\"\"\"\n278:         service = EmbeddingService()\n279:         \n280:         # Text with only spaces at boundary\n281:         space_text = \" \" * service.MIN_SPLIT_CHARS\n282:         texts = [space_text]\n283:         mock_client = MagicMock()\n284: \n285:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n286:             mock_client_class.return_value.__aenter__.return_value = mock_client\n287:             mock_client.post = AsyncMock(side_effect=self._create_overflow_error())\n288: \n289:             with pytest.raises(EmbeddingError) as context:\n290:                 await service.embed_batch(texts, batch_size=1)\n291: \n292:             # Should handle gracefully\n293:             assert context.value is not None\n294: \n295:     @pytest.mark.asyncio\n296:     async def test_text_single_character_with_overflow(self):\n297:         \"\"\"ATTACK: Single character text that still triggers overflow error.\"\"\"\n298:         service = EmbeddingService()\n299:         \n300:         texts = [\"a\"]  # Single character\n301:         mock_client = MagicMock()\n302: \n303:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n304:             mock_client_class.return_value.__aenter__.return_value = mock_client\n305:             mock_client.post = AsyncMock(side_effect=self._create_overflow_error())\n306: \n307:             with pytest.raises(EmbeddingError) as context:\n308:                 await service.embed_batch(texts, batch_size=1)\n309: \n310:             # Single char is way below MIN_SPLIT_CHARS\n311:             error_msg = str(context.value).lower()\n312:             assert \"too short\" in error_msg or \"1 char\" in error_msg\n313: \n314:     @pytest.mark.asyncio\n315:     async def test_split_produces_empty_left_side(self):\n316:         \"\"\"ATTACK: Force split to produce empty left side via midpoint math.\"\"\"\n317:         service = EmbeddingService()\n318:         \n319:         # Test the _split_text_at_midpoint directly with edge cases\n320:         # Text of length 1 should return (text, \"\")\n321:         result = service._split_text_at_midpoint(\"a\")\n322:         assert result == (\"a\", \"\"), \"Single char should return (text, empty)\"\n323: \n324:     @pytest.mark.asyncio\n325:     async def test_split_text_two_characters(self):\n326:         \"\"\"ATTACK: Split exactly 2 characters at midpoint.\"\"\"\n327:         service = EmbeddingService()\n328:         \n329:         result = service._split_text_at_midpoint(\"ab\")\n330:         # Midpoint is 1, so \"ab\" -> (\"a\", \"b\")\n331:         assert result == (\"a\", \"b\")\n332: \n333:     @pytest.mark.asyncio\n334:     async def test_split_text_three_characters(self):\n335:         \"\"\"ATTACK: Split exactly 3 characters at midpoint.\"\"\"\n336:         service = EmbeddingService()\n337:         \n338:         result = service._split_text_at_midpoint(\"abc\")\n339:         # Midpoint is 1 (3//2=1), so \"abc\" -> (\"a\", \"bc\")\n340:         assert result == (\"a\", \"bc\")\n341: \n342: \n343: # ==============================================================================\n344: # ATTACK VECTOR 3: REPEATED OVERFLOW RECURSION PRESSURE\n345: # ==============================================================================\n346: \n347: class TestRepeatedOverflowRecursionPressure:\n348:     \"\"\"Tests for recursion depth limits and retry exhaustion under sustained overflow.\"\"\"\n349: \n350:     @pytest.fixture(autouse=True)\n351:     def setup(self):\n352:         self.mock_settings_patcher = patch('app.services.embeddings.settings')\n353:         self.mock_settings = self.mock_settings_patcher.start()\n354:         self._configure_settings()\n355: \n356:     def _configure_settings(self):\n357:         self.mock_settings.ollama_embedding_url = \"http://localhost:11434/api/embeddings\"\n358:         self.mock_settings.embedding_model = \"nomic-embed-text\"\n359:         self.mock_settings.embedding_doc_prefix = \"\"\n360:         self.mock_settings.embedding_query_prefix = \"\"\n361:         self.mock_settings.embedding_batch_size = 512\n362:         self.mock_settings.embedding_batch_max_retries = 3\n363:         self.mock_settings.embedding_batch_min_sub_size = 1\n364:         self.mock_settings.chunk_size_chars = 1200\n365:         self.mock_settings.chunk_overlap_chars = 120\n366: \n367:     @pytest.fixture(autouse=True)\n368:     def teardown(self):\n369:         yield\n370:         self.mock_settings_patcher.stop()\n371: \n372:     def _create_overflow_error(self, message=\"input (4096 tokens) is too large to process, current batch size: 1024\"):\n373:         return HTTPError(message)\n374: \n375:     def _create_mock_response(self, embeddings):\n376:         \"\"\"Create a mock HTTP response with embeddings.\"\"\"\n377:         response = MagicMock()\n378:         response.status_code = 200\n379:         response.json.return_value = {\"embeddings\": embeddings}\n380:         return response\n381: \n382:     @pytest.mark.asyncio\n383:     async def test_max_retries_exhaustion_single_input(self):\n384:         \"\"\"ATTACK: Sustained overflow until retry limit exhausted or split too small.\"\"\"\n385:         service = EmbeddingService()\n386:         \n387:         # Text long enough to always attempt split\n388:         long_text = \"x\" * 500\n389:         texts = [long_text]\n390:         \n391:         call_count = [0]\n392:         mock_client = MagicMock()\n393: \n394:         async def mock_post_always_overflow(*args, **kwargs):\n395:             call_count[0] += 1\n396:             raise self._create_overflow_error()\n397: \n398:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n399:             mock_client_class.return_value.__aenter__.return_value = mock_client\n400:             mock_client.post = mock_post_always_overflow\n401: \n402:             with pytest.raises(EmbeddingError) as context:\n403:                 await service.embed_batch(texts, batch_size=1)\n404: \n405:             error_msg = str(context.value).lower()\n406:             # Should indicate retry exhaustion OR too short to split\n407:             # (depending on whether text splits below MIN_SPLIT_CHARS first)\n408:             assert (\"max retries\" in error_msg or \"exhausted\" in error_msg or \n409:                     \"too short\" in error_msg or \"minimum\" in error_msg)\n410:             # Verify we didn't make infinite calls\n411:             assert call_count[0] < 50, f\"Too many calls ({call_count[0]}), potential infinite loop\"\n412: \n413:     @pytest.mark.asyncio\n414:     async def test_overflow_with_very_low_max_retries(self):\n415:         \"\"\"ATTACK: Test with max_retries set to 0.\"\"\"\n416:         # Reconfigure with 0 retries\n417:         self.mock_settings.embedding_batch_max_retries = 0\n418:         service = EmbeddingService()\n419:         \n420:         texts = [\"a\" * 500]\n421:         mock_client = MagicMock()\n422: \n423:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n424:             mock_client_class.return_value.__aenter__.return_value = mock_client\n425:             mock_client.post = AsyncMock(side_effect=self._create_overflow_error())\n426: \n427:             with pytest.raises(EmbeddingError) as context:\n428:                 await service.embed_batch(texts, batch_size=1)\n429: \n430:             # Should fail immediately\n431:             error_msg = str(context.value).lower()\n432:             assert \"max retries\" in error_msg or \"exhausted\" in error_msg\n433: \n434:     @pytest.mark.asyncio\n435:     async def test_overflow_with_negative_max_retries(self):\n436:         \"\"\"ATTACK: Test with negative max_retries (should not crash).\"\"\"\n437:         # Reconfigure with negative retries\n438:         self.mock_settings.embedding_batch_max_retries = -1\n439:         service = EmbeddingService()\n440:         \n441:         texts = [\"a\" * 500]\n442:         mock_client = MagicMock()\n443: \n444:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n445:             mock_client_class.return_value.__aenter__.return_value = mock_client\n446:             mock_client.post = AsyncMock(side_effect=self._create_overflow_error())\n447: \n448:             # Should not crash, should handle gracefully\n449:             with pytest.raises(EmbeddingError) as context:\n450:                 await service.embed_batch(texts, batch_size=1)\n451: \n452:             assert context.value is not None\n453: \n454:     @pytest.mark.asyncio\n455:     async def test_recursive_split_until_text_too_small(self):\n456:         \"\"\"ATTACK: Text that keeps overflowing until parts become too small to split.\"\"\"\n457:         service = EmbeddingService()\n458:         \n459:         # Text that's just above MIN_SPLIT_CHARS so one split will push it below\n460:         # 201 chars - split becomes ~100 each, which is below 200\n461:         texts = [\"x\" * 201]\n462:         \n463:         call_count = [0]\n464:         mock_client = MagicMock()\n465: \n466:         async def mock_post_always_overflow(*args, **kwargs):\n467:             call_count[0] += 1\n468:             raise self._create_overflow_error()\n469: \n470:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n471:             mock_client_class.return_value.__aenter__.return_value = mock_client\n472:             mock_client.post = mock_post_always_overflow\n473: \n474:             with pytest.raises(EmbeddingError) as context:\n475:                 await service.embed_batch(texts, batch_size=1)\n476: \n477:             # After first split, parts are ~100 chars, below MIN_SPLIT_CHARS\n478:             # Next overflow should fail with \"too short to split\"\n479:             error_msg = str(context.value).lower()\n480:             assert \"too short to split\" in error_msg or \"max retries\" in error_msg\n481: \n482:     @pytest.mark.asyncio\n483:     async def test_multi_batch_overflow_to_single_item(self):\n484:         \"\"\"ATTACK: Multi-item batch that overflows down to single items.\"\"\"\n485:         service = EmbeddingService()\n486:         \n487:         # Start with 8 items, all will overflow until we reach single items\n488:         texts = [f\"item_{i}_{'x' * 100}\" for i in range(8)]\n489:         \n490:         call_count = [0]\n491:         responses = []\n492: \n493:         # Create enough overflow errors to push to single items\n494:         # 8 -> 4 -> 2 -> 1 = many overflows needed\n495:         for _ in range(50):  # Over-provide overflow errors\n496:             responses.append(self._create_overflow_error())\n497:         \n498:         # Eventually provide success\n499:         responses.append(self._create_mock_response([[0.1] * 768]))\n500:         \n501:         async def mock_post(*args, **kwargs):\n502:             call_count[0] += 1\n503:             if responses:\n504:                 resp = responses.pop(0)\n505:                 if isinstance(resp, HTTPError):\n506:                     raise resp\n507:                 return resp\n508:             raise self._create_overflow_error()\n509: \n510:         mock_client = MagicMock()\n511: \n512:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n513:             mock_client_class.return_value.__aenter__.return_value = mock_client\n514:             mock_client.post = mock_post\n515: \n516:             # This will either succeed or fail with bounded retries\n517:             try:\n518:                 result = await service.embed_batch(texts, batch_size=8)\n519:                 # If it succeeds, verify we got 8 embeddings\n520:                 assert len(result) == 8\n521:             except EmbeddingError:\n522:                 # If it fails, verify it's due to retry exhaustion, not crash\n523:                 pass\n524: \n525:             # Verify bounded execution\n526:             assert call_count[0] < 100, f\"Too many calls ({call_count[0]}), potential unbounded recursion\"\n527: \n528: \n529: # ==============================================================================\n530: # ATTACK VECTOR 4: UNEXPECTED RESPONSE SHAPES\n531: # ==============================================================================\n532: \n533: class TestUnexpectedResponseShapes:\n534:     \"\"\"Tests for malformed, incomplete, or unexpected API response structures.\"\"\"\n535: \n536:     @pytest.fixture(autouse=True)\n537:     def setup(self):\n538:         self.mock_settings_patcher = patch('app.services.embeddings.settings')\n539:         self.mock_settings = self.mock_settings_patcher.start()\n540:         self._configure_settings()\n541: \n542:     def _configure_settings(self):\n543:         self.mock_settings.ollama_embedding_url = \"http://localhost:11434/api/embeddings\"\n544:         self.mock_settings.embedding_model = \"nomic-embed-text\"\n545:         self.mock_settings.embedding_doc_prefix = \"\"\n546:         self.mock_settings.embedding_query_prefix = \"\"\n547:         self.mock_settings.embedding_batch_size = 512\n548:         self.mock_settings.embedding_batch_max_retries = 3\n549:         self.mock_settings.embedding_batch_min_sub_size = 1\n550:         self.mock_settings.chunk_size_chars = 1200\n551:         self.mock_settings.chunk_overlap_chars = 120\n552: \n553:     @pytest.fixture(autouse=True)\n554:     def teardown(self):\n555:         yield\n556:         self.mock_settings_patcher.stop()\n557: \n558:     def _create_mock_response_with_data(self, data):\n559:         \"\"\"Create a mock response with custom data.\"\"\"\n560:         response = MagicMock()\n561:         response.status_code = 200\n562:         response.json.return_value = data\n563:         return response\n564: \n565:     def _create_overflow_response_500(self, error_text: str):\n566:         \"\"\"Create a mock 500 response with custom error text.\"\"\"\n567:         response = MagicMock()\n568:         response.status_code = 500\n569:         response.text = error_text\n570:         response.json.side_effect = ValueError(\"Not JSON\")\n571:         return response\n572: \n573:     @pytest.mark.asyncio\n574:     async def test_response_missing_embeddings_key(self):\n575:         \"\"\"ATTACK: Response missing 'embeddings' key in Ollama mode.\"\"\"\n576:         service = EmbeddingService()\n577:         texts = [\"test text\"]\n578:         \n579:         mock_client = MagicMock()\n580:         response = self._create_mock_response_with_data({\"wrong_key\": []})\n581: \n582:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n583:             mock_client_class.return_value.__aenter__.return_value = mock_client\n584:             mock_client.post = AsyncMock(return_value=response)\n585: \n586:             with pytest.raises(EmbeddingError) as context:\n587:                 await service.embed_batch(texts, batch_size=1)\n588: \n589:             assert \"unexpected\" in str(context.value).lower() or \"invalid\" in str(context.value).lower()\n590: \n591:     @pytest.mark.asyncio\n592:     async def test_response_empty_embeddings_list(self):\n593:         \"\"\"ATTACK: Response with empty embeddings list.\"\"\"\n594:         service = EmbeddingService()\n595:         texts = [\"test text\"]\n596:         \n597:         mock_client = MagicMock()\n598:         response = self._create_mock_response_with_data({\"embeddings\": []})\n599: \n600:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n601:             mock_client_class.return_value.__aenter__.return_value = mock_client\n602:             mock_client.post = AsyncMock(return_value=response)\n603: \n604:             with pytest.raises(EmbeddingError) as context:\n605:                 await service.embed_batch(texts, batch_size=1)\n606: \n607:             assert \"mismatch\" in str(context.value).lower() or \"invalid\" in str(context.value).lower()\n608: \n609:     @pytest.mark.asyncio\n610:     async def test_response_embeddings_count_mismatch(self):\n611:         \"\"\"ATTACK: Response with wrong number of embeddings.\"\"\"\n612:         service = EmbeddingService()\n613:         texts = [\"text1\", \"text2\", \"text3\"]\n614:         \n615:         # Return only 2 embeddings for 3 texts\n616:         mock_client = MagicMock()\n617:         response = self._create_mock_response_with_data({\n618:             \"embeddings\": [[0.1] * 768, [0.2] * 768]\n619:         })\n620: \n621:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n622:             mock_client_class.return_value.__aenter__.return_value = mock_client\n623:             mock_client.post = AsyncMock(return_value=response)\n624: \n625:             with pytest.raises(EmbeddingError) as context:\n626:                 await service.embed_batch(texts, batch_size=5)\n627: \n628:             assert \"mismatch\" in str(context.value).lower()\n629: \n630:     @pytest.mark.asyncio\n631:     async def test_response_embedding_not_a_list(self):\n632:         \"\"\"ATTACK: Response where embedding is not a list.\"\"\"\n633:         service = EmbeddingService()\n634:         texts = [\"test text\"]\n635:         \n636:         mock_client = MagicMock()\n637:         response = self._create_mock_response_with_data({\n638:             \"embeddings\": [\"not a list of floats\"]\n639:         })\n640: \n641:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n642:             mock_client_class.return_value.__aenter__.return_value = mock_client\n643:             mock_client.post = AsyncMock(return_value=response)\n644: \n645:             with pytest.raises(EmbeddingError) as context:\n646:                 await service.embed_batch(texts, batch_size=1)\n647: \n648:             assert \"not a list\" in str(context.value).lower() or \"invalid\" in str(context.value).lower()\n649: \n650:     @pytest.mark.asyncio\n651:     async def test_response_embedding_values_not_numbers(self):\n652:         \"\"\"ATTACK: Response where embedding values are not numbers.\"\"\"\n653:         service = EmbeddingService()\n654:         texts = [\"test text\"]\n655:         \n656:         mock_client = MagicMock()\n657:         response = self._create_mock_response_with_data({\n658:             \"embeddings\": [[\"string\", None, {\"nested\": \"object\"}]]\n659:         })\n660: \n661:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n662:             mock_client_class.return_value.__aenter__.return_value = mock_client\n663:             mock_client.post = AsyncMock(return_value=response)\n664: \n665:             with pytest.raises(EmbeddingError) as context:\n666:                 await service.embed_batch(texts, batch_size=1)\n667: \n668:             assert \"not a number\" in str(context.value).lower() or \"invalid\" in str(context.value).lower()\n669: \n670:     @pytest.mark.asyncio\n671:     async def test_response_embeddings_is_string_instead_of_list(self):\n672:         \"\"\"ATTACK: Response where 'embeddings' is a string.\"\"\"\n673:         service = EmbeddingService()\n674:         texts = [\"test text\"]\n675:         \n676:         mock_client = MagicMock()\n677:         response = self._create_mock_response_with_data({\n678:             \"embeddings\": \"this should be a list\"\n679:         })\n680: \n681:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n682:             mock_client_class.return_value.__aenter__.return_value = mock_client\n683:             mock_client.post = AsyncMock(return_value=response)\n684: \n685:             with pytest.raises(EmbeddingError) as context:\n686:                 await service.embed_batch(texts, batch_size=1)\n687: \n688:             assert \"not a list\" in str(context.value).lower() or \"invalid\" in str(context.value).lower()\n689: \n690:     @pytest.mark.asyncio\n691:     async def test_response_single_embedding_for_batch(self):\n692:         \"\"\"ATTACK: Response returns single embedding instead of array for batch.\"\"\"\n693:         service = EmbeddingService()\n694:         texts = [\"text1\", \"text2\"]\n695:         \n696:         mock_client = MagicMock()\n697:         # Single embedding object instead of array\n698:         response = self._create_mock_response_with_data({\n699:             \"embedding\": [0.1] * 768\n700:         })\n701: \n702:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n703:             mock_client_class.return_value.__aenter__.return_value = mock_client\n704:             mock_client.post = AsyncMock(return_value=response)\n705: \n706:             with pytest.raises(EmbeddingError) as context:\n707:                 await service.embed_batch(texts, batch_size=5)\n708: \n709:             # Should fail due to count mismatch or unexpected format\n710:             assert context.value is not None\n711: \n712:     @pytest.mark.asyncio\n713:     async def test_response_null_embedding_in_list(self):\n714:         \"\"\"ATTACK: Response with null/None in embeddings list.\"\"\"\n715:         service = EmbeddingService()\n716:         texts = [\"text1\", \"text2\"]\n717:         \n718:         mock_client = MagicMock()\n719:         response = self._create_mock_response_with_data({\n720:             \"embeddings\": [[0.1] * 768, None]  # Second is None\n721:         })\n722: \n723:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n724:             mock_client_class.return_value.__aenter__.return_value = mock_client\n725:             mock_client.post = AsyncMock(return_value=response)\n726: \n727:             with pytest.raises(EmbeddingError) as context:\n728:                 await service.embed_batch(texts, batch_size=5)\n729: \n730:             assert \"not a list\" in str(context.value).lower() or \"invalid\" in str(context.value).lower()\n731: \n732:     @pytest.mark.asyncio\n733:     async def test_response_with_nan_values(self):\n734:         \"\"\"ATTACK: Response with NaN values in embedding.\"\"\"\n735:         service = EmbeddingService()\n736:         texts = [\"test text\"]\n737:         \n738:         mock_client = MagicMock()\n739:         response = self._create_mock_response_with_data({\n740:             \"embeddings\": [[float('nan')] * 768]\n741:         })\n742: \n743:         # NaN is technically a float, so this might pass validation\n744:         # but should be tested for completeness\n745:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n746:             mock_client_class.return_value.__aenter__.return_value = mock_client\n747:             mock_client.post = AsyncMock(return_value=response)\n748: \n749:             # Should either succeed (NaN is a float) or fail gracefully\n750:             try:\n751:                 result = await service.embed_batch(texts, batch_size=1)\n752:                 assert len(result) == 1\n753:             except EmbeddingError:\n754:                 pass  # Acceptable to reject NaN\n755: \n756:     @pytest.mark.asyncio\n757:     async def test_response_with_infinity_values(self):\n758:         \"\"\"ATTACK: Response with infinity values in embedding.\"\"\"\n759:         service = EmbeddingService()\n760:         texts = [\"test text\"]\n761:         \n762:         mock_client = MagicMock()\n763:         response = self._create_mock_response_with_data({\n764:             \"embeddings\": [[float('inf')] * 768]\n765:         })\n766: \n767:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n768:             mock_client_class.return_value.__aenter__.return_value = mock_client\n769:             mock_client.post = AsyncMock(return_value=response)\n770: \n771:             # Should either succeed (inf is a float) or fail gracefully\n772:             try:\n773:                 result = await service.embed_batch(texts, batch_size=1)\n774:                 assert len(result) == 1\n775:             except EmbeddingError:\n776:                 pass  # Acceptable to reject infinity\n777: \n778:     @pytest.mark.xfail(reason=\"BUG: OpenAI batch mode raises KeyError instead of EmbeddingError for missing 'data' key - line 378 accesses data['data'] without validation\")\n779:     @pytest.mark.asyncio\n780:     async def test_openai_mode_missing_data_key(self):\n781:         \"\"\"ATTACK: OpenAI mode response missing 'data' key.\n782:         \n783:         BUG DETECTED: Code raises KeyError instead of EmbeddingError.\n784:         The _embed_batch_with_retry method accesses data['data'] without validation (line 378).\n785:         \"\"\"\n786:         self.mock_settings.ollama_embedding_url = \"http://localhost:1234/v1/embeddings\"\n787:         service = EmbeddingService()\n788:         \n789:         assert service.provider_mode == 'openai'\n790:         texts = [\"test text\"]\n791:         \n792:         mock_client = MagicMock()\n793:         response = self._create_mock_response_with_data({\"wrong\": \"structure\"})\n794: \n795:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n796:             mock_client_class.return_value.__aenter__.return_value = mock_client\n797:             mock_client.post = AsyncMock(return_value=response)\n798: \n799:             # Should raise EmbeddingError, not KeyError\n800:             with pytest.raises(EmbeddingError) as context:\n801:                 await service.embed_batch(texts, batch_size=1)\n802: \n803:             assert \"invalid\" in str(context.value).lower() or \"missing\" in str(context.value).lower()\n804: \n805:     @pytest.mark.asyncio\n806:     async def test_openai_mode_data_is_empty_list(self):\n807:         \"\"\"ATTACK: OpenAI mode response with empty 'data' list.\"\"\"\n808:         self.mock_settings.ollama_embedding_url = \"http://localhost:1234/v1/embeddings\"\n809:         service = EmbeddingService()\n810:         \n811:         texts = [\"test text\"]\n812:         \n813:         mock_client = MagicMock()\n814:         response = self._create_mock_response_with_data({\"data\": []})\n815: \n816:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n817:             mock_client_class.return_value.__aenter__.return_value = mock_client\n818:             mock_client.post = AsyncMock(return_value=response)\n819: \n820:             with pytest.raises(EmbeddingError) as context:\n821:                 await service.embed_batch(texts, batch_size=1)\n822: \n823:             # Empty list causes count mismatch\n824:             error_msg = str(context.value).lower()\n825:             assert \"mismatch\" in error_msg or \"invalid\" in error_msg or \"empty\" in error_msg\n826: \n827:     @pytest.mark.xfail(reason=\"BUG: OpenAI batch mode raises KeyError instead of EmbeddingError for missing 'embedding' key - line 378 accesses item['embedding'] without validation\")\n828:     @pytest.mark.asyncio\n829:     async def test_openai_mode_data_missing_embedding(self):\n830:         \"\"\"ATTACK: OpenAI mode response data item missing 'embedding' key.\n831:         \n832:         BUG DETECTED: Code raises KeyError instead of EmbeddingError.\n833:         The _embed_batch_with_retry method accesses item['embedding'] without validation (line 378).\n834:         \"\"\"\n835:         self.mock_settings.ollama_embedding_url = \"http://localhost:1234/v1/embeddings\"\n836:         service = EmbeddingService()\n837:         \n838:         texts = [\"test text\"]\n839:         \n840:         mock_client = MagicMock()\n841:         response = self._create_mock_response_with_data({\n842:             \"data\": [{\"wrong_key\": \"value\"}]\n843:         })\n844: \n845:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n846:             mock_client_class.return_value.__aenter__.return_value = mock_client\n847:             mock_client.post = AsyncMock(return_value=response)\n848: \n849:             # Should raise EmbeddingError, not KeyError\n850:             with pytest.raises(EmbeddingError) as context:\n851:                 await service.embed_batch(texts, batch_size=1)\n852: \n853:             assert \"invalid\" in str(context.value).lower() or \"missing\" in str(context.value).lower()\n854: \n855:     @pytest.mark.xfail(reason=\"BUG: Batch mode raises ValueError instead of EmbeddingError for invalid JSON - line 373 response.json() not wrapped in try/except\")\n856:     @pytest.mark.asyncio\n857:     async def test_response_is_not_valid_json(self):\n858:         \"\"\"ATTACK: Response is not valid JSON.\n859:         \n860:         BUG DETECTED: Code raises raw ValueError instead of EmbeddingError.\n861:         The _embed_batch_with_retry method doesn't wrap JSON parsing errors (line 373).\n862:         Note: embed_single handles this correctly (lines 188-194), but batch mode does not.\n863:         \"\"\"\n864:         service = EmbeddingService()\n865:         texts = [\"test text\"]\n866:         \n867:         mock_client = MagicMock()\n868:         response = MagicMock()\n869:         response.status_code = 200\n870:         response.json.side_effect = ValueError(\"Invalid JSON\")\n871:         response.text = \"not json at all\"\n872: \n873:         with patch('app.services.embeddings.httpx.AsyncClient') as mock_client_class:\n874:             mock_client_class.return_value.__aenter__.return_value = mock_client\n875:             mock_client.post = AsyncMock(return_value=response)\n876: \n877:             # Should raise EmbeddingError, not ValueError\n878:             with pytest.raises(EmbeddingError) as context:\n879:                 await service.embed_batch(texts, batch_size=1)\n880: \n881:             assert \"invalid\" in str(context.value).lower()\n882: \n883: \n884: # ==============================================================================\n885: # ADDITIONAL EDGE CASES: MEAN POOLING ATTACKS\n886: # ==============================================================================\n887: \n888: class TestMeanPoolingAttacks:\n889:     \"\"\"Tests for mean-pooling edge cases and dimension mismatches.\"\"\"\n890: \n891:     @pytest.fixture(autouse=True)\n892:     def setup(self):\n893:         self.mock_settings_patcher = patch('app.services.embeddings.settings')\n894:         self.mock_settings = self.mock_settings_patcher.start()\n895:         self._configure_settings()\n896: \n897:     def _configure_settings(self):\n898:         self.mock_settings.ollama_embedding_url = \"http://localhost:11434/api/embeddings\"\n899:         self.mock_settings.embedding_model = \"nomic-embed-text\"\n900:         self.mock_settings.embedding_doc_prefix = \"\"\n901:         self.mock_settings.embedding_query_prefix = \"\"\n902:         self.mock_settings.embedding_batch_size = 512\n903:         self.mock_settings.embedding_batch_max_retries = 3\n904:         self.mock_settings.embedding_batch_min_sub_size = 1\n905:         self.mock_settings.chunk_size_chars = 1200\n906:         self.mock_settings.chunk_overlap_chars = 120\n907: \n908:     @pytest.fixture(autouse=True)\n909:     def teardown(self):\n910:         yield\n911:         self.mock_settings_patcher.stop()\n912: \n913:     def test_mean_pool_different_dimensions_raises(self):\n914:         \"\"\"ATTACK: Mean pooling with different dimension vectors.\"\"\"\n915:         service = EmbeddingService()\n916:         \n917:         emb1 = [0.1] * 768\n918:         emb2 = [0.2] * 512  # Different dimension\n919:         \n920:         with pytest.raises(EmbeddingError) as context:\n921:             service._mean_pool_embeddings(emb1, emb2)\n922:         \n923:         assert \"different dimensions\" in str(context.value).lower()\n924: \n925:     def test_mean_pool_empty_embeddings(self):\n926:         \"\"\"ATTACK: Mean pooling with empty vectors.\"\"\"\n927:         service = EmbeddingService()\n928:         \n929:         emb1 = []\n930:         emb2 = []\n931:         \n932:         # Empty vectors have same dimension (0), so should work\n933:         result = service._mean_pool_embeddings(emb1, emb2)\n934:         assert result == []\n935: \n936:     def test_mean_pool_one_empty_one_full(self):\n937:         \"\"\"ATTACK: Mean pooling one empty and one full vector.\"\"\"\n938:         service = EmbeddingService()\n939:         \n940:         emb1 = []\n941:         emb2 = [0.1, 0.2, 0.3]\n942:         \n943:         with pytest.raises(EmbeddingError) as context:\n944:             service._mean_pool_embeddings(emb1, emb2)\n945:         \n946:         assert \"different dimensions\" in str(context.value).lower()\n947: \n948:     def test_mean_pool_single_element(self):\n949:         \"\"\"ATTACK: Mean pooling single element vectors.\"\"\"\n950:         service = EmbeddingService()\n951:         \n952:         result = service._mean_pool_embeddings([1.0], [3.0])\n953:         assert result == [2.0]  # (1 + 3) / 2\n954: \n955: \n956: # ==============================================================================\n957: # INPUT VALIDATION ATTACKS\n958: # ==============================================================================\n959: \n960: class TestInputValidationAttacks:\n961:     \"\"\"Tests for input validation edge cases.\"\"\"\n962: \n963:     @pytest.fixture(autouse=True)\n964:     def setup(self):\n965:         self.mock_settings_patcher = patch('app.services.embeddings.settings')\n966:         self.mock_settings = self.mock_settings_patcher.start()\n967:         self._configure_settings()\n968: \n969:     def _configure_settings(self):\n970:         self.mock_settings.ollama_embedding_url = \"http://localhost:11434/api/embeddings\"\n971:         self.mock_settings.embedding_model = \"nomic-embed-text\"\n972:         self.mock_settings.embedding_doc_prefix = \"\"\n973:         self.mock_settings.embedding_query_prefix = \"\"\n974:         self.mock_settings.embedding_batch_size = 512\n975:         self.mock_settings.embedding_batch_max_retries = 3\n976:         self.mock_settings.embedding_batch_min_sub_size = 1\n977:         self.mock_settings.chunk_size_chars = 1200\n978:         self.mock_settings.chunk_overlap_chars = 120\n979: \n980:     @pytest.fixture(autouse=True)\n981:     def teardown(self):\n982:         yield\n983:         self.mock_settings_patcher.stop()\n984: \n985:     @pytest.mark.asyncio\n986:     async def test_embed_batch_with_none_in_list(self):\n987:         \"\"\"ATTACK: embed_batch with None in text list.\"\"\"\n988:         service = EmbeddingService()\n989:         texts = [\"valid\", None, \"also valid\"]\n990: \n991:         with pytest.raises(EmbeddingError) as context:\n992:             await service.embed_batch(texts)\n993: \n994:         assert \"none\" in str(context.value).lower() or \"index 1\" in str(context.value).lower()\n995: \n996:     @pytest.mark.asyncio\n997:     async def test_embed_batch_with_empty_string(self):\n998:         \"\"\"ATTACK: embed_batch with empty string in list.\"\"\"\n999:         service = EmbeddingService()\n1000:         texts = [\"valid\", \"\", \"also valid\"]\n1001: \n1002:         with pytest.raises(EmbeddingError) as context:\n1003:             await service.embed_batch(texts)\n1004: \n1005:         assert \"empty\" in str(context.value).lower()\n1006: \n1007:     @pytest.mark.asyncio\n1008:     async def test_embed_batch_with_whitespace_only(self):\n1009:         \"\"\"ATTACK: embed_batch with whitespace-only string.\"\"\"\n1010:         service = EmbeddingService()\n1011:         texts = [\"valid\", \"   \\t\\n   \", \"also valid\"]\n1012: \n1013:         with pytest.raises(EmbeddingError) as context:\n1014:             await service.embed_batch(texts)\n1015: \n1016:         assert \"empty\" in str(context.value).lower() or \"whitespace\" in str(context.value).lower()\n1017: \n1018:     @pytest.mark.asyncio\n1019:     async def test_embed_batch_exceeds_max_text_length(self):\n1020:         \"\"\"ATTACK: embed_batch with text exceeding MAX_TEXT_LENGTH.\"\"\"\n1021:         service = EmbeddingService()\n1022:         \n1023:         # Create text that exceeds MAX_TEXT_LENGTH (8192)\n1024:         long_text = \"x\" * (service.MAX_TEXT_LENGTH + 1)\n1025:         texts = [long_text]\n1026: \n1027:         with pytest.raises(EmbeddingError) as context:\n1028:             await service.embed_batch(texts)\n1029: \n1030:         assert \"exceeds maximum length\" in str(context.value).lower()\n1031: \n1032:     @pytest.mark.asyncio\n1033:     async def test_embed_single_none_text(self):\n1034:         \"\"\"ATTACK: embed_single with None text.\"\"\"\n1035:         service = EmbeddingService()\n1036: \n1037:         with pytest.raises(EmbeddingError) as context:\n1038:             await service.embed_single(None)\n1039: \n1040:         assert \"none\" in str(context.value).lower()\n1041: \n1042:     @pytest.mark.asyncio\n1043:     async def test_embed_single_empty_text(self):\n1044:         \"\"\"ATTACK: embed_single with empty text.\"\"\"\n1045:         service = EmbeddingService()\n1046: \n1047:         with pytest.raises(EmbeddingError) as context:\n1048:             await service.embed_single(\"\")\n1049: \n1050:         assert \"empty\" in str(context.value).lower()\n1051: \n1052:     @pytest.mark.asyncio\n1053:     async def test_embed_single_whitespace_only(self):\n1054:         \"\"\"ATTACK: embed_single with whitespace-only text.\"\"\"\n1055:         service = EmbeddingService()\n1056: \n1057:         with pytest.raises(EmbeddingError) as context:\n1058:             await service.embed_single(\"   \\t\\n   \")\n1059: \n1060:         assert \"empty\" in str(context.value).lower() or \"whitespace\" in str(context.value).lower()\n1061: \n1062:     @pytest.mark.asyncio\n1063:     async def test_validate_dimension_none(self):\n1064:         \"\"\"ATTACK: validate_embedding_dimension with None.\"\"\"\n1065:         service = EmbeddingService()\n1066: \n1067:         with pytest.raises(EmbeddingError) as context:\n1068:             await service.validate_embedding_dimension(None)\n1069: \n1070:         assert \"none\" in str(context.value).lower()\n1071: \n1072:     @pytest.mark.asyncio\n1073:     async def test_validate_dimension_zero(self):\n1074:         \"\"\"ATTACK: validate_embedding_dimension with zero.\"\"\"\n1075:         service = EmbeddingService()\n1076: \n1077:         with pytest.raises(EmbeddingError) as context:\n1078:             await service.validate_embedding_dimension(0)\n1079: \n1080:         assert \"positive\" in str(context.value).lower()\n1081: \n1082:     @pytest.mark.asyncio\n1083:     async def test_validate_dimension_negative(self):\n1084:         \"\"\"ATTACK: validate_embedding_dimension with negative.\"\"\"\n1085:         service = EmbeddingService()\n1086: \n1087:         with pytest.raises(EmbeddingError) as context:\n1088:             await service.validate_embedding_dimension(-100)\n1089: \n1090:         assert \"positive\" in str(context.value).lower()\n1091: \n1092:     @pytest.mark.asyncio\n\n...439 bytes truncated...\n\nThe tool call succeeded but the output was truncated. Full output saved to: C:\\Users\\zaxby\\.local\\share\\opencode\\tool-output\\tool_c8fbf3020001x5KKrUYPMeU7SV\nUse the Task tool to have explore agent process this file with Grep and Read (with offset/limit). Do NOT read the full file yourself - delegate to save context.","timestamp":1771938197549,"originalBytes":51527}