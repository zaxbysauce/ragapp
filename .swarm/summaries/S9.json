{"id":"S9","summaryText":"[SUMMARY S9] 39.6 KB | code | 894 lines\n<path>C:\\opencode\\RAGAPPv2\\backend\\tests\\test_email_service.py</path>\n<type>file</type>\n<content>1: \"\"\"\n2: Unit tests for EmailIngestionService.\n3: \n→ Use /swarm retrieve S9 for full content","fullOutput":"<path>C:\\opencode\\RAGAPPv2\\backend\\tests\\test_email_service.py</path>\n<type>file</type>\n<content>1: \"\"\"\n2: Unit tests for EmailIngestionService.\n3: \n4: Tests cover:\n5: - Vault name extraction from subject tags\n6: - Attachment validation (MIME types, size limits)\n7: - Email parsing (text/HTML, multipart)\n8: - IMAP connection (exponential backoff, auth failure)\n9: - Service integration (start/stop, health check)\n10: \"\"\"\n11: \n12: import asyncio\n13: import email\n14: import email.policy\n15: import os\n16: import sys\n17: import tempfile\n18: import types\n19: import unittest\n20: from datetime import datetime\n21: from email.message import EmailMessage\n22: from pathlib import Path\n23: from unittest.mock import AsyncMock, MagicMock, patch\n24: \n25: # Add parent directory to path for imports\n26: sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))\n27: \n28: # Stub missing optional dependencies\n29: try:\n30:     import lancedb\n31: except ImportError:\n32:     sys.modules['lancedb'] = types.ModuleType('lancedb')\n33: \n34: try:\n35:     import pyarrow\n36: except ImportError:\n37:     sys.modules['pyarrow'] = types.ModuleType('pyarrow')\n38: \n39: try:\n40:     from unstructured.partition.auto import partition\n41: except ImportError:\n42:     _unstructured = types.ModuleType('unstructured')\n43:     _unstructured.__path__ = []\n44:     _unstructured.partition = types.ModuleType('unstructured.partition')\n45:     _unstructured.partition.__path__ = []\n46:     _unstructured.partition.auto = types.ModuleType('unstructured.partition.auto')\n47:     _unstructured.partition.auto.partition = lambda *args, **kwargs: []\n48:     _unstructured.chunking = types.ModuleType('unstructured.chunking')\n49:     _unstructured.chunking.__path__ = []\n50:     _unstructured.chunking.title = types.ModuleType('unstructured.chunking.title')\n51:     _unstructured.chunking.title.chunk_by_title = lambda *args, **kwargs: []\n52:     _unstructured.documents = types.ModuleType('unstructured.documents')\n53:     _unstructured.documents.__path__ = []\n54:     _unstructured.documents.elements = types.ModuleType('unstructured.documents.elements')\n55:     _unstructured.documents.elements.Element = type('Element', (), {})\n56:     sys.modules['unstructured'] = _unstructured\n57:     sys.modules['unstructured.partition'] = _unstructured.partition\n58:     sys.modules['unstructured.partition.auto'] = _unstructured.partition.auto\n59:     sys.modules['unstructured.chunking'] = _unstructured.chunking\n60:     sys.modules['unstructured.chunking.title'] = _unstructured.chunking.title\n61:     sys.modules['unstructured.documents'] = _unstructured.documents\n62:     sys.modules['unstructured.documents.elements'] = _unstructured.documents.elements\n63: \n64: try:\n65:     import aioimaplib\n66: except ImportError:\n67:     sys.modules['aioimaplib'] = types.ModuleType('aioimaplib')\n68: \n69: from app.config import Settings\n70: from app.models.database import SQLiteConnectionPool\n71: from app.services.email_service import EmailIngestionService\n72: from pydantic import SecretStr\n73: \n74: \n75: class FakeBackgroundProcessor:\n76:     \"\"\"Fake BackgroundProcessor for testing.\"\"\"\n77: \n78:     def __init__(self):\n79:         self.enqueued = []\n80: \n81:     async def enqueue(self, file_path, source=None, email_subject=None, email_sender=None):\n82:         self.enqueued.append({\n83:             'file_path': file_path,\n84:             'source': source,\n85:             'email_subject': email_subject,\n86:             'email_sender': email_sender,\n87:         })\n88: \n89: \n90: class FakeIMAPClient:\n91:     \"\"\"Fake aioimaplib.IMAP4_SSL for testing.\"\"\"\n92: \n93:     def __init__(self):\n94:         self.selected_mailbox = None\n95:         self.searched = False\n96:         self.fetched_uids = []\n97:         self.logged_out = False\n98:         self.emails = {}  # uid -> email data\n99: \n100:     async def wait_hello_from_server(self):\n101:         return 'OK'\n102: \n103:     async def login(self, username, password):\n104:         return ('OK', None)\n105: \n106:     async def select(self, mailbox):\n107:         self.selected_mailbox = mailbox\n108:         return ('OK', None)\n109: \n110:     async def search(self, charset, criterion):\n111:         self.searched = True\n112:         uids = ' '.join(self.emails.keys()).encode()\n113:         return ('OK', [uids])\n114: \n115:     async def fetch(self, uid, parts):\n116:         if uid in self.emails:\n117:             email_data = self.emails[uid]\n118:             if 'RFC822.SIZE' in parts:\n119:                 size = len(email_data['content'])\n120:                 return ('OK', [(b'1 (RFC822.SIZE {size})',)])\n121:             elif 'RFC822' in parts:\n122:                 # Real aioimaplib returns: [(b'uid (RFC822 {size})', b'...email content...')]\n123:                 # where data[0][0] is the response string and data[0][1] is the email bytes\n124:                 return ('OK', [(b'1 (RFC822)', email_data['content'])])\n125:         return ('OK', [])\n126: \n127:     async def logout(self):\n128:         self.logged_out = True\n129:         return ('OK', None)\n130: \n131: \n132: class TestVaultNameExtraction(unittest.TestCase):\n133:     \"\"\"Test vault name extraction from subject tags.\"\"\"\n134: \n135:     def setUp(self):\n136:         self.temp_dir = tempfile.mkdtemp()\n137:         self.settings = self._create_test_settings()\n138:         self.pool = self._create_test_pool()\n139:         self.background_processor = FakeBackgroundProcessor()\n140:         self.service = EmailIngestionService(\n141:             self.settings,\n142:             self.pool,\n143:             self.background_processor\n144:         )\n145: \n146:     def tearDown(self):\n147:         self.pool.close_all()\n148:         import shutil\n149:         shutil.rmtree(self.temp_dir, ignore_errors=True)\n150: \n151:     def _create_test_settings(self):\n152:         settings = Settings()\n153:         settings.data_dir = Path(self.temp_dir)\n154:         settings.uploads_dir.mkdir(parents=True, exist_ok=True)\n155:         return settings\n156: \n157:     def _create_test_pool(self):\n158:         db_path = os.path.join(self.temp_dir, 'test.db')\n159:         from app.models.database import init_db\n160:         init_db(db_path)\n161:         return SQLiteConnectionPool(db_path, max_size=2)\n162: \n163:     def test_extract_vault_name_bracket_pattern(self):\n164:         \"\"\"Test [VaultName] bracket pattern extraction.\"\"\"\n165:         subject = \"Document regarding [ProjectX] specifications\"\n166:         vault_name = self.service._extract_vault_name(subject)\n167:         self.assertEqual(vault_name, \"ProjectX\")\n168: \n169:     def test_extract_vault_name_hashtag_pattern(self):\n170:         \"\"\"Test #vaultname hashtag pattern extraction.\"\"\"\n171:         subject = \"Document regarding #marketing specifications\"\n172:         vault_name = self.service._extract_vault_name(subject)\n173:         self.assertEqual(vault_name, \"marketing\")\n174: \n175:     def test_extract_vault_name_no_tag_returns_none(self):\n176:         \"\"\"Test no tag returns None.\"\"\"\n177:         subject = \"Document regarding project specifications\"\n178:         vault_name = self.service._extract_vault_name(subject)\n179:         self.assertIsNone(vault_name)\n180: \n181:     def test_extract_vault_name_bracket_hashtag_priority(self):\n182:         \"\"\"Test bracket pattern takes priority over hashtag.\"\"\"\n183:         subject = \"[HR] Document with #finance tag\"\n184:         vault_name = self.service._extract_vault_name(subject)\n185:         self.assertEqual(vault_name, \"HR\")  # First pattern wins\n186: \n187:     def test_extract_vault_name_case_insensitive(self):\n188:         \"\"\"Test case insensitivity (extraction preserves case).\"\"\"\n189:         subject = \"Document for [SALES]\"\n190:         vault_name = self.service._extract_vault_name(subject)\n191:         self.assertEqual(vault_name, \"SALES\")\n192: \n193:     def test_extract_vault_name_multiple_bracket_tags(self):\n194:         \"\"\"Test multiple bracket tags (first wins).\"\"\"\n195:         subject = \"[TeamA] forwarded from [TeamB] document\"\n196:         vault_name = self.service._extract_vault_name(subject)\n197:         self.assertEqual(vault_name, \"TeamA\")\n198: \n199:     def test_extract_vault_name_multiple_hashtag_tags(self):\n200:         \"\"\"Test multiple hashtag tags (first wins).\"\"\"\n201:         subject = \"#dev discussion about #ops issue\"\n202:         vault_name = self.service._extract_vault_name(subject)\n203:         self.assertEqual(vault_name, \"dev\")\n204: \n205:     def test_extract_vault_name_empty_brackets(self):\n206:         \"\"\"Test empty brackets return None.\"\"\"\n207:         subject = \"Document with [] empty tag\"\n208:         vault_name = self.service._extract_vault_name(subject)\n209:         self.assertIsNone(vault_name)\n210: \n211:     def test_extract_vault_name_whitespace_handling(self):\n212:         \"\"\"Test whitespace trimming around tag content.\"\"\"\n213:         subject = \"Document [  spaced  ] with spaces\"\n214:         vault_name = self.service._extract_vault_name(subject)\n215:         self.assertEqual(vault_name, \"spaced\")\n216: \n217: \n218: class TestAttachmentValidation(unittest.TestCase):\n219:     \"\"\"Test attachment validation logic.\"\"\"\n220: \n221:     def setUp(self):\n222:         self.temp_dir = tempfile.mkdtemp()\n223:         self.settings = self._create_test_settings()\n224:         self.pool = self._create_test_pool()\n225:         self.background_processor = FakeBackgroundProcessor()\n226:         self.service = EmailIngestionService(\n227:             self.settings,\n228:             self.pool,\n229:             self.background_processor\n230:         )\n231: \n232:     def tearDown(self):\n233:         self.pool.close_all()\n234:         import shutil\n235:         shutil.rmtree(self.temp_dir, ignore_errors=True)\n236: \n237:     def _create_test_settings(self):\n238:         settings = Settings()\n239:         settings.data_dir = Path(self.temp_dir)\n240:         settings.uploads_dir.mkdir(parents=True, exist_ok=True)\n241:         return settings\n242: \n243:     def _create_test_pool(self):\n244:         db_path = os.path.join(self.temp_dir, 'test.db')\n245:         from app.models.database import init_db\n246:         init_db(db_path)\n247:         return SQLiteConnectionPool(db_path, max_size=2)\n248: \n249:     def _create_attachment_part(self, content_type, payload):\n250:         \"\"\"Helper to create an email attachment part.\"\"\"\n251:         part = EmailMessage()\n252:         part.set_content(payload, maintype=content_type.split('/')[0],\n253:                          subtype=content_type.split('/')[1])\n254:         part.add_header('Content-Disposition', 'attachment')\n255:         return part\n256: \n257:     def test_validate_pdf_mime_type_allowed(self):\n258:         \"\"\"Test PDF MIME type passes validation.\"\"\"\n259:         part = self._create_attachment_part('application/pdf', b'fake pdf content')\n260:         is_valid, reason = self.service._validate_attachment(part)\n261:         self.assertTrue(is_valid)\n262:         self.assertEqual(reason, \"\")\n263: \n264:     def test_validate_plain_text_mime_type_allowed(self):\n265:         \"\"\"Test plain text MIME type passes validation.\"\"\"\n266:         part = self._create_attachment_part('text/plain', b'Hello world')\n267:         is_valid, reason = self.service._validate_attachment(part)\n268:         self.assertTrue(is_valid)\n269:         self.assertEqual(reason, \"\")\n270: \n271:     def test_validate_markdown_mime_type_allowed(self):\n272:         \"\"\"Test markdown MIME type passes validation.\"\"\"\n273:         part = self._create_attachment_part('text/markdown', b'# Title')\n274:         is_valid, reason = self.service._validate_attachment(part)\n275:         self.assertTrue(is_valid)\n276:         self.assertEqual(reason, \"\")\n277: \n278:     def test_validate_docx_mime_type_allowed(self):\n279:         \"\"\"Test DOCX MIME type passes validation.\"\"\"\n280:         part = self._create_attachment_part(\n281:             'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n282:             b'fake docx content'\n283:         )\n284:         is_valid, reason = self.service._validate_attachment(part)\n285:         self.assertTrue(is_valid)\n286:         self.assertEqual(reason, \"\")\n287: \n288:     def test_validate_csv_mime_type_allowed(self):\n289:         \"\"\"Test CSV MIME type passes validation.\"\"\"\n290:         part = self._create_attachment_part('text/csv', b'name,value\\nfoo,bar')\n291:         is_valid, reason = self.service._validate_attachment(part)\n292:         self.assertTrue(is_valid)\n293:         self.assertEqual(reason, \"\")\n294: \n295:     def test_validate_json_mime_type_allowed(self):\n296:         \"\"\"Test JSON MIME type passes validation.\"\"\"\n297:         part = self._create_attachment_part('application/json', b'{\"key\": \"value\"}')\n298:         is_valid, reason = self.service._validate_attachment(part)\n299:         self.assertTrue(is_valid)\n300:         self.assertEqual(reason, \"\")\n301: \n302:     def test_validate_disallowed_mime_type_fails(self):\n303:         \"\"\"Test disallowed MIME type fails validation.\"\"\"\n304:         part = self._create_attachment_part('application/zip', b'fake zip content')\n305:         is_valid, reason = self.service._validate_attachment(part)\n306:         self.assertFalse(is_valid)\n307:         self.assertIn(\"Disallowed MIME type\", reason)\n308: \n309:     def test_validate_exe_mime_type_fails(self):\n310:         \"\"\"Test EXE MIME type fails validation.\"\"\"\n311:         part = self._create_attachment_part('application/x-msdownload', b'fake exe content')\n312:         is_valid, reason = self.service._validate_attachment(part)\n313:         self.assertFalse(is_valid)\n314:         self.assertIn(\"Disallowed MIME type\", reason)\n315: \n316:     def test_validate_image_mime_type_fails(self):\n317:         \"\"\"Test image MIME type fails validation.\"\"\"\n318:         part = self._create_attachment_part('image/jpeg', b'fake jpeg content')\n319:         is_valid, reason = self.service._validate_attachment(part)\n320:         self.assertFalse(is_valid)\n321:         self.assertIn(\"Disallowed MIME type\", reason)\n322: \n323:     def test_validate_size_limit_enforced(self):\n324:         \"\"\"Test size limit is enforced.\"\"\"\n325:         large_payload = b'x' * (11 * 1024 * 1024)  # 11MB > default 10MB\n326:         part = self._create_attachment_part('application/pdf', large_payload)\n327:         is_valid, reason = self.service._validate_attachment(part)\n328:         self.assertFalse(is_valid)\n329:         self.assertIn(\"File too large\", reason)\n330: \n331:     def test_validate_exactly_at_size_limit_passes(self):\n332:         \"\"\"Test attachment exactly at size limit passes.\"\"\"\n333:         exact_payload = b'x' * (10 * 1024 * 1024)  # Exactly 10MB\n334:         part = self._create_attachment_part('application/pdf', exact_payload)\n335:         is_valid, reason = self.service._validate_attachment(part)\n336:         self.assertTrue(is_valid)\n337:         self.assertEqual(reason, \"\")\n338: \n339:     def test_validate_oversized_attachment_rejected(self):\n340:         \"\"\"Test oversized attachment is rejected.\"\"\"\n341:         huge_payload = b'x' * (20 * 1024 * 1024)  # 20MB\n342:         part = self._create_attachment_part('application/pdf', huge_payload)\n343:         is_valid, reason = self.service._validate_attachment(part)\n344:         self.assertFalse(is_valid)\n345:         self.assertIn(\"File too large\", reason)\n346:         self.assertIn(\"20.00MB\", reason)\n347: \n348:     def test_validate_empty_attachment_passes(self):\n349:         \"\"\"Test empty attachment passes validation.\"\"\"\n350:         part = self._create_attachment_part('text/plain', b'')\n351:         is_valid, reason = self.service._validate_attachment(part)\n352:         self.assertTrue(is_valid)\n353:         self.assertEqual(reason, \"\")\n354: \n355: \n356: class TestEmailParsing(unittest.TestCase):\n357:     \"\"\"Test email parsing and extraction.\"\"\"\n358: \n359:     def setUp(self):\n360:         self.temp_dir = tempfile.mkdtemp()\n361:         self.settings = self._create_test_settings()\n362:         self.pool = self._create_test_pool()\n363:         self.background_processor = FakeBackgroundProcessor()\n364:         self.service = EmailIngestionService(\n365:             self.settings,\n366:             self.pool,\n367:             self.background_processor\n368:         )\n369: \n370:     def tearDown(self):\n371:         self.pool.close_all()\n372:         import shutil\n373:         shutil.rmtree(self.temp_dir, ignore_errors=True)\n374: \n375:     def _create_test_settings(self):\n376:         settings = Settings()\n377:         settings.data_dir = Path(self.temp_dir)\n378:         settings.uploads_dir.mkdir(parents=True, exist_ok=True)\n379:         return settings\n380: \n381:     def _create_test_pool(self):\n382:         db_path = os.path.join(self.temp_dir, 'test.db')\n383:         from app.models.database import init_db\n384:         init_db(db_path)\n385:         return SQLiteConnectionPool(db_path, max_size=2)\n386: \n387:     def test_decode_header_value_simple_text(self):\n388:         \"\"\"Test decoding simple text header value.\"\"\"\n389:         value = \"Simple Subject\"\n390:         decoded = self.service._decode_header_value(value)\n391:         self.assertEqual(decoded, \"Simple Subject\")\n392: \n393:     def test_decode_header_value_encoded_utf8(self):\n394:         \"\"\"Test decoding UTF-8 encoded header value.\"\"\"\n395:         value = \"=?utf-8?B?5Lit5paH?=\"  # \"中文\" in base64\n396:         decoded = self.service._decode_header_value(value)\n397:         self.assertEqual(decoded, \"中文\")\n398: \n399:     def test_decode_header_value_multiple_parts(self):\n400:         \"\"\"Test decoding header with multiple encoded parts.\"\"\"\n401:         value = \"Hello =?utf-8?B?5Lit5paH?= World\"\n402:         decoded = self.service._decode_header_value(value)\n403:         self.assertEqual(decoded, \"Hello 中文 World\")\n404: \n405:     def test_decode_header_value_empty_returns_empty(self):\n406:         \"\"\"Test empty header value returns empty string.\"\"\"\n407:         decoded = self.service._decode_header_value(\"\")\n408:         self.assertEqual(decoded, \"\")\n409: \n410:     def test_decode_header_value_none_returns_empty(self):\n411:         \"\"\"Test None header value returns empty string.\"\"\"\n412:         decoded = self.service._decode_header_value(None)\n413:         self.assertEqual(decoded, \"\")\n414: \n415:     def test_sanitize_html_allowed_tags(self):\n416:         \"\"\"Test HTML sanitization allows only allowed tags.\"\"\"\n417:         html = \"<p>Hello <strong>world</strong></p><script>alert('xss')</script>\"\n418:         sanitized = self.service._sanitize_html(html)\n419:         self.assertIn(\"<p>Hello <strong>world</strong></p>\", sanitized)\n420:         self.assertNotIn(\"<script>\", sanitized)\n421:         # Note: bleach strips tags but leaves text content\n422:         self.assertIn(\"alert\", sanitized)\n423: \n424:     def test_sanitize_html_strips_disallowed_tags(self):\n425:         \"\"\"Test HTML sanitization strips disallowed tags.\"\"\"\n426:         html = \"<div><h1>Title</h1></div><p>Content</p>\"\n427:         sanitized = self.service._sanitize_html(html)\n428:         self.assertNotIn(\"<div>\", sanitized)\n429:         self.assertNotIn(\"<h1>\", sanitized)\n430:         self.assertIn(\"Title\", sanitized)\n431:         self.assertIn(\"<p>\", sanitized)\n432: \n433:     def test_sanitize_html_strips_comments(self):\n434:         \"\"\"Test HTML sanitization strips comments.\"\"\"\n435:         html = \"<p>Content</p><!-- This is a comment --><p>More content</p>\"\n436:         sanitized = self.service._sanitize_html(html)\n437:         self.assertNotIn(\"<!-- This is a comment -->\", sanitized)\n438:         self.assertIn(\"<p>Content</p>\", sanitized)\n439:         self.assertIn(\"<p>More content</p>\", sanitized)\n440: \n441:     def test_sanitize_log_value_removes_newlines(self):\n442:         \"\"\"Test log sanitization removes newlines.\"\"\"\n443:         value = \"Line 1\\nLine 2\\r\\nLine 3\"\n444:         sanitized = self.service._sanitize_log_value(value)\n445:         self.assertNotIn(\"\\n\", sanitized)\n446:         self.assertNotIn(\"\\r\", sanitized)\n447:         # Note: \\r\\n is replaced with two spaces (one for \\r, one for \\n)\n448:         self.assertIn(\"Line 1 Line 2\", sanitized)\n449:         self.assertIn(\"Line 3\", sanitized)\n450: \n451:     def test_sanitize_log_value_removes_control_chars(self):\n452:         \"\"\"Test log sanitization removes control characters.\"\"\"\n453:         value = \"Text\\x00with\\x1fcontrol\\x7fchars\"\n454:         sanitized = self.service._sanitize_log_value(value)\n455:         self.assertNotIn(\"\\x00\", sanitized)\n456:         self.assertNotIn(\"\\x1f\", sanitized)\n457:         self.assertNotIn(\"\\x7f\", sanitized)\n458: \n459:     def test_sanitize_log_value_empty_returns_empty(self):\n460:         \"\"\"Test empty log value returns empty string.\"\"\"\n461:         sanitized = self.service._sanitize_log_value(\"\")\n462:         self.assertEqual(sanitized, \"\")\n463: \n464:     def test_sanitize_log_value_none_returns_empty(self):\n465:         \"\"\"Test None log value returns empty string.\"\"\"\n466:         sanitized = self.service._sanitize_log_value(None)\n467:         self.assertEqual(sanitized, \"\")\n468: \n469:     def test_sanitize_filename_removes_path_traversal(self):\n470:         \"\"\"Test filename sanitization removes path traversal.\"\"\"\n471:         filename = \"../../../etc/passwd\"\n472:         sanitized = self.service._sanitize_filename(filename)\n473:         self.assertEqual(sanitized, \"passwd\")\n474: \n475:     def test_sanitize_filename_windows_path_traversal(self):\n476:         \"\"\"Test filename sanitization removes Windows path traversal.\"\"\"\n477:         filename = \"..\\\\..\\\\..\\\\windows\\\\system32\\\\config\\\\sam\"\n478:         sanitized = self.service._sanitize_filename(filename)\n479:         self.assertEqual(sanitized, \"sam\")\n480: \n481:     def test_sanitize_filename_normal_filename(self):\n482:         \"\"\"Test normal filename is unchanged.\"\"\"\n483:         filename = \"document.pdf\"\n484:         sanitized = self.service._sanitize_filename(filename)\n485:         self.assertEqual(sanitized, \"document.pdf\")\n486: \n487:     def test_sanitize_filename_none_returns_none(self):\n488:         \"\"\"Test None filename returns None.\"\"\"\n489:         sanitized = self.service._sanitize_filename(None)\n490:         self.assertIsNone(sanitized)\n491: \n492: \n493: class TestIMAPConnection(unittest.IsolatedAsyncioTestCase):\n494:     \"\"\"Test IMAP connection logic with exponential backoff.\"\"\"\n495: \n496:     def setUp(self):\n497:         self.temp_dir = tempfile.mkdtemp()\n498:         self.settings = self._create_test_settings()\n499:         self.pool = self._create_test_pool()\n500:         self.background_processor = FakeBackgroundProcessor()\n501:         self.service = EmailIngestionService(\n502:             self.settings,\n503:             self.pool,\n504:             self.background_processor\n505:         )\n506: \n507:     def tearDown(self):\n508:         self.pool.close_all()\n509:         import shutil\n510:         shutil.rmtree(self.temp_dir, ignore_errors=True)\n511: \n512:     def _create_test_settings(self):\n513:         settings = Settings()\n514:         settings.imap_host = \"test.example.com\"\n515:         settings.imap_port = 993\n516:         settings.imap_username = \"test@example.com\"\n517:         settings.imap_password = SecretStr(\"password123\")\n518:         settings.data_dir = Path(self.temp_dir)\n519:         settings.uploads_dir.mkdir(parents=True, exist_ok=True)\n520:         return settings\n521: \n522:     def _create_test_pool(self):\n523:         db_path = os.path.join(self.temp_dir, 'test.db')\n524:         from app.models.database import init_db\n525:         init_db(db_path)\n526:         return SQLiteConnectionPool(db_path, max_size=2)\n527: \n528:     async def test_connect_with_backoff_success_first_attempt(self):\n529:         \"\"\"Test successful connection on first attempt.\"\"\"\n530:         fake_imap = FakeIMAPClient()\n531: \n532:         with patch('app.services.email_service.aioimaplib.IMAP4_SSL', return_value=fake_imap):\n533:             result = await self.service._connect_with_backoff()\n534:             self.assertEqual(result, fake_imap)\n535:             self.assertIsNone(self.service.get_current_backoff_delay())\n536: \n537:     async def test_connect_with_backoff_retry_logic(self):\n538:         \"\"\"Test exponential backoff retry logic.\"\"\"\n539:         attempt_count = 0\n540:         fake_imap = FakeIMAPClient()\n541: \n542:         def mock_imap_connection(*args, **kwargs):\n543:             nonlocal attempt_count\n544:             attempt_count += 1\n545:             if attempt_count < 3:\n546:                 raise Exception(\"Connection failed\")\n547:             return fake_imap\n548: \n549:         with patch('app.services.email_service.aioimaplib.IMAP4_SSL', side_effect=mock_imap_connection):\n550:             result = await self.service._connect_with_backoff()\n551:             self.assertEqual(result, fake_imap)\n552:             self.assertEqual(attempt_count, 3)\n553:             # Backoff delay should be set during retries\n554:             self.assertIsNone(self.service.get_current_backoff_delay())  # Cleared on success\n555: \n556:     async def test_connect_with_backoff_auth_failure_no_retry(self):\n557:         \"\"\"Test auth failure doesn't trigger retry.\"\"\"\n558:         fake_imap = FakeIMAPClient()\n559:         # Make login fail\n560:         fake_imap.login = AsyncMock(return_value=('NO', None))\n561: \n562:         with patch('app.services.email_service.aioimaplib.IMAP4_SSL', return_value=fake_imap):\n563:             with self.assertRaises(Exception) as ctx:\n564:                 await self.service._connect_with_backoff()\n565:             self.assertIn(\"authentication\", str(ctx.exception).lower())\n566: \n567:     async def test_connect_with_backoff_max_delay_reached(self):\n568:         \"\"\"Test backoff delay caps at max (60s) before giving up.\"\"\"\n569:         attempt_count = 0\n570:         fake_imap = FakeIMAPClient()\n571: \n572:         def mock_imap_connection(*args, **kwargs):\n573:             nonlocal attempt_count\n574:             attempt_count += 1\n575:             raise Exception(\"Connection failed\")\n576: \n577:         with patch('app.services.email_service.aioimaplib.IMAP4_SSL', side_effect=mock_imap_connection):\n578:             with self.assertRaises(Exception) as ctx:\n579:                 await self.service._connect_with_backoff()\n580:             self.assertIn(\"failed after\", str(ctx.exception))\n581:             self.assertEqual(attempt_count, 4)  # 5s -> 15s -> 45s -> 60s (max)\n582: \n583:     async def test_connect_with_backoff_gives_up_after_max_retries(self):\n584:         \"\"\"Test gives up after max delay reached and still failing.\"\"\"\n585:         fake_imap = FakeIMAPClient()\n586: \n587:         def mock_imap_connection(*args, **kwargs):\n588:             raise Exception(\"Persistent connection failure\")\n589: \n590:         with patch('app.services.email_service.aioimaplib.IMAP4_SSL', side_effect=mock_imap_connection):\n591:             with self.assertRaises(Exception) as ctx:\n592:                 await self.service._connect_with_backoff()\n593:             self.assertIn(\"failed after\", str(ctx.exception))\n594: \n595:     async def test_connect_with_backoff_stop_event_interrupts(self):\n596:         \"\"\"Test stop event interrupts backoff.\"\"\"\n597:         fake_imap = FakeIMAPClient()\n598: \n599:         def mock_imap_connection(*args, **kwargs):\n600:             raise Exception(\"Connection failed\")\n601: \n602:         with patch('app.services.email_service.aioimaplib.IMAP4_SSL', side_effect=mock_imap_connection):\n603:             # Set stop event to interrupt\n604:             self.service._stop_event.set()\n605:             with self.assertRaises(Exception) as ctx:\n606:                 await self.service._connect_with_backoff()\n607:             self.assertIn(\"stopped during connection\", str(ctx.exception))\n608: \n609: \n610: class TestEmailServiceIntegration(unittest.IsolatedAsyncioTestCase):\n611:     \"\"\"Test email service integration.\"\"\"\n612: \n613:     def setUp(self):\n614:         self.temp_dir = tempfile.mkdtemp()\n615:         self.settings = self._create_test_settings()\n616:         self.pool = self._create_test_pool()\n617:         self.background_processor = FakeBackgroundProcessor()\n618:         self.service = EmailIngestionService(\n619:             self.settings,\n620:             self.pool,\n621:             self.background_processor\n622:         )\n623: \n624:     def tearDown(self):\n625:         self.pool.close_all()\n626:         import shutil\n627:         shutil.rmtree(self.temp_dir, ignore_errors=True)\n628: \n629:     def _create_test_settings(self):\n630:         settings = Settings()\n631:         settings.imap_enabled = True\n632:         settings.imap_host = \"test.example.com\"\n633:         settings.imap_port = 993\n634:         settings.imap_username = \"test@example.com\"\n635:         settings.imap_password = SecretStr(\"password123\")\n636:         settings.imap_mailbox = \"INBOX\"\n637:         settings.imap_poll_interval = 10  # Short for tests\n638:         settings.data_dir = Path(self.temp_dir)\n639:         settings.uploads_dir.mkdir(parents=True, exist_ok=True)\n640:         return settings\n641: \n642:     def _create_test_pool(self):\n643:         db_path = os.path.join(self.temp_dir, 'test.db')\n644:         from app.models.database import init_db\n645:         init_db(db_path)\n646:         return SQLiteConnectionPool(db_path, max_size=2)\n647: \n648:     async def test_service_initialization(self):\n649:         \"\"\"Test service initializes correctly.\"\"\"\n650:         self.assertIsNotNone(self.service)\n651:         self.assertFalse(self.service._running)\n652:         self.assertIsNone(self.service._polling_task)\n653:         self.assertIsNone(self.service._last_error)\n654:         self.assertIsNone(self.service._last_poll_time)\n655: \n656:     async def test_start_polling_sets_running_flag(self):\n657:         \"\"\"Test start_polling sets running flag.\"\"\"\n658:         fake_imap = FakeIMAPClient()\n659: \n660:         with patch('app.services.email_service.aioimaplib.IMAP4_SSL', return_value=fake_imap):\n661:             await self.service.start_polling()\n662:             self.assertTrue(self.service._running)\n663:             self.assertIsNotNone(self.service._polling_task)\n664: \n665:             # Stop the service\n666:             self.service.stop_polling()\n667:             # Wait a bit for stop to propagate\n668:             await asyncio.sleep(0.1)\n669: \n670:     async def test_start_polling_when_already_running(self):\n671:         \"\"\"Test start_polling is idempotent when already running.\"\"\"\n672:         fake_imap = FakeIMAPClient()\n673: \n674:         with patch('app.services.email_service.aioimaplib.IMAP4_SSL', return_value=fake_imap):\n675:             await self.service.start_polling()\n676:             first_task = self.service._polling_task\n677: \n678:             # Start again (should not create duplicate poller)\n679:             await self.service.start_polling()\n680:             second_task = self.service._polling_task\n681: \n682:             self.assertEqual(first_task, second_task)\n683: \n684:             # Stop the service\n685:             self.service.stop_polling()\n686:             await asyncio.sleep(0.1)\n687: \n688:     async def test_start_polling_when_disabled(self):\n689:         \"\"\"Test start_polling does nothing when IMAP disabled.\"\"\"\n690:         self.settings.imap_enabled = False\n691:         service = EmailIngestionService(\n692:             self.settings,\n693:             self.pool,\n694:             self.background_processor\n695:         )\n696: \n697:         await service.start_polling()\n698:         self.assertFalse(service._running)\n699:         self.assertIsNone(service._polling_task)\n700: \n701:     async def test_stop_polling_when_not_running(self):\n702:         \"\"\"Test stop_polling handles not running gracefully.\"\"\"\n703:         # Should not raise exception\n704:         self.service.stop_polling()\n705:         self.assertFalse(self.service._running)\n706: \n707:     async def test_stop_polling_sets_stop_event(self):\n708:         \"\"\"Test stop_polling sets stop event.\"\"\"\n709:         fake_imap = FakeIMAPClient()\n710: \n711:         with patch('app.services.email_service.aioimaplib.IMAP4_SSL', return_value=fake_imap):\n712:             await self.service.start_polling()\n713:             self.assertFalse(self.service._stop_event.is_set())\n714: \n715:             self.service.stop_polling()\n716:             self.assertTrue(self.service._stop_event.is_set())\n717: \n718:             # Wait a bit for stop to propagate\n719:             await asyncio.sleep(0.1)\n720: \n721:     async def test_is_healthy_true_when_running_no_errors(self):\n722:         \"\"\"Test is_healthy returns True when running without errors.\"\"\"\n723:         self.service._running = True\n724:         self.service._last_error = None\n725:         self.assertTrue(self.service.is_healthy())\n726: \n727:     async def test_is_healthy_false_when_not_running(self):\n728:         \"\"\"Test is_healthy returns False when not running.\"\"\"\n729:         self.service._running = False\n730:         self.service._last_error = None\n731:         self.assertFalse(self.service.is_healthy())\n732: \n733:     async def test_is_healthy_false_when_has_error(self):\n734:         \"\"\"Test is_healthy returns False when has error.\"\"\"\n735:         self.service._running = True\n736:         self.service._last_error = \"Connection failed\"\n737:         self.assertFalse(self.service.is_healthy())\n738: \n739:     async def test_get_last_poll_time(self):\n740:         \"\"\"Test get_last_poll_time returns correct value.\"\"\"\n741:         self.assertIsNone(self.service.get_last_poll_time())\n742: \n743:         test_time = datetime(2026, 2, 19, 12, 0, 0)\n744:         self.service._last_poll_time = test_time\n745:         self.assertEqual(self.service.get_last_poll_time(), test_time)\n746: \n747:     async def test_get_current_backoff_delay(self):\n748:         \"\"\"Test get_current_backoff_delay returns correct value.\"\"\"\n749:         self.assertIsNone(self.service.get_current_backoff_delay())\n750: \n751:         self.service._current_backoff_delay = 30\n752:         self.assertEqual(self.service.get_current_backoff_delay(), 30)\n753: \n754:     async def test_process_email_with_attachment(self):\n755:         \"\"\"Test processing email with attachment.\"\"\"\n756:         fake_imap = FakeIMAPClient()\n757: \n758:         # Create test email with attachment\n759:         msg = EmailMessage()\n760:         msg['Subject'] = 'Test Document [Vault1]'\n761:         msg['From'] = 'sender@example.com'\n762:         msg.set_content('Email body')\n763:         msg.add_attachment(\n764:             b'PDF content',\n765:             maintype='application',\n766:             subtype='pdf',\n767:             filename='test.pdf'\n768:         )\n769: \n770:         fake_imap.emails = {'1': {'content': msg.as_bytes()}}\n771: \n772:         with patch('app.services.email_service.aioimaplib.IMAP4_SSL', return_value=fake_imap):\n773:             await self.service._process_email(fake_imap, '1')\n774: \n775:             # Check attachment was enqueued\n776:             self.assertEqual(len(self.background_processor.enqueued), 1)\n777:             self.assertEqual(self.background_processor.enqueued[0]['source'], 'email')\n778: \n779:     async def test_process_email_with_disallowed_mime_type(self):\n780:         \"\"\"Test processing email with disallowed MIME type.\"\"\"\n781:         fake_imap = FakeIMAPClient()\n782: \n783:         # Create test email with disallowed attachment\n784:         msg = EmailMessage()\n785:         msg['Subject'] = 'Test Document'\n786:         msg['From'] = 'sender@example.com'\n787:         msg.set_content('Email body')\n788:         msg.add_attachment(\n789:             b'EXE content',\n790:             maintype='application',\n791:             subtype='x-msdownload',\n792:             filename='test.exe'\n793:         )\n794: \n795:         fake_imap.emails = {'1': {'content': msg.as_bytes()}}\n796: \n797:         with patch('app.services.email_service.aioimaplib.IMAP4_SSL', return_value=fake_imap):\n798:             await self.service._process_email(fake_imap, '1')\n799: \n800:             # Check nothing was enqueued\n801:             self.assertEqual(len(self.background_processor.enqueued), 0)\n802: \n803:     async def test_process_email_with_oversized_attachment(self):\n804:         \"\"\"Test processing email with oversized attachment.\"\"\"\n805:         fake_imap = FakeIMAPClient()\n806: \n807:         # Create test email with oversized attachment\n808:         large_content = b'x' * (11 * 1024 * 1024)  # 11MB\n809:         msg = EmailMessage()\n810:         msg['Subject'] = 'Test Document'\n811:         msg['From'] = 'sender@example.com'\n812:         msg.set_content('Email body')\n813:         msg.add_attachment(\n814:             large_content,\n815:             maintype='application',\n816:             subtype='pdf',\n817:             filename='large.pdf'\n818:         )\n819: \n820:         fake_imap.emails = {'1': {'content': msg.as_bytes()}}\n821: \n822:         with patch('app.services.email_service.aioimaplib.IMAP4_SSL', return_value=fake_imap):\n823:             await self.service._process_email(fake_imap, '1')\n824: \n825:             # Check nothing was enqueued\n826:             self.assertEqual(len(self.background_processor.enqueued), 0)\n827: \n828:     async def test_process_email_multiple_attachments(self):\n829:         \"\"\"Test processing email with multiple attachments.\"\"\"\n830:         fake_imap = FakeIMAPClient()\n831: \n832:         # Create test email with multiple attachments\n833:         msg = EmailMessage()\n834:         msg['Subject'] = 'Test Document [Vault1]'\n835:         msg['From'] = 'sender@example.com'\n836:         msg.set_content('Email body')\n837:         msg.add_attachment(b'PDF content 1', maintype='application', subtype='pdf', filename='test1.pdf')\n838:         msg.add_attachment(b'PDF content 2', maintype='application', subtype='pdf', filename='test2.pdf')\n839:         msg.add_attachment(b'PDF content 3', maintype='application', subtype='pdf', filename='test3.pdf')\n840: \n841:         fake_imap.emails = {'1': {'content': msg.as_bytes()}}\n842: \n843:         with patch('app.services.email_service.aioimaplib.IMAP4_SSL', return_value=fake_imap):\n844:             await self.service._process_email(fake_imap, '1')\n845: \n846:             # Check all 3 attachments were enqueued\n847:             self.assertEqual(len(self.background_processor.enqueued), 3)\n848: \n849:     async def test_resolve_vault_id_found(self):\n850:         \"\"\"Test resolving vault ID when vault exists.\"\"\"\n851:         # Insert test vault (will be id=2 since default vault is id=1)\n852:         conn = self.pool.get_connection()\n853:         conn.execute(\"INSERT INTO vaults (name) VALUES (?)\", (\"TestVault\",))\n854:         conn.commit()\n855:         vault_id = conn.execute(\"SELECT last_insert_rowid()\").fetchone()[0]\n856:         self.pool.release_connection(conn)\n857: \n858:         resolved_id = await self.service._resolve_vault_id(\"TestVault\")\n859:         self.assertEqual(resolved_id, vault_id)\n860: \n861:     async def test_resolve_vault_id_not_found(self):\n862:         \"\"\"Test resolving vault ID returns default (1) when not found.\"\"\"\n863:         vault_id = await self.service._resolve_vault_id(\"NonExistentVault\")\n864:         self.assertEqual(vault_id, 1)\n865: \n866:     async def test_resolve_vault_id_none(self):\n867:         \"\"\"Test resolving vault ID returns default (1) when vault_name is None.\"\"\"\n868:         vault_id = await self.service._resolve_vault_id(None)\n869:         self.assertEqual(vault_id, 1)\n870: \n871:     async def test_resolve_vault_id_case_insensitive(self):\n872:         \"\"\"Test vault resolution is case-insensitive.\"\"\"\n873:         # Insert test vault (will be id=3 since default is id=1 and previous test added id=2)\n874:         conn = self.pool.get_connection()\n875:         conn.execute(\"INSERT INTO vaults (name) VALUES (?)\", (\"MyVault\",))\n876:         conn.commit()\n877:         vault_id = conn.execute(\"SELECT last_insert_rowid()\").fetchone()[0]\n878:         self.pool.release_connection(conn)\n879: \n880:         resolved_id = await self.service._resolve_vault_id(\"myvault\")\n881:         self.assertEqual(resolved_id, vault_id)\n882: \n883:         resolved_id = await self.service._resolve_vault_id(\"MYVAULT\")\n884:         self.assertEqual(resolved_id, vault_id)\n885: \n886: \n887: if __name__ == '__main__':\n888:     unittest.main()\n889: \n\n(End of file - total 889 lines)\n</content>","timestamp":1771496950985,"originalBytes":40530}