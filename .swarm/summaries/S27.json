{"id":"S27","summaryText":"[SUMMARY S27] 27.4 KB | code | 685 lines\n<path>C:\\opencode\\RAGAPPv2\\backend\\tests\\test_api_routes.py</path>\n<type>file</type>\n<content>1: \"\"\"\n2: Backend API route tests using unittest and FastAPI TestClient.\n3: \nâ†’ Use /swarm retrieve S27 for full content","fullOutput":"<path>C:\\opencode\\RAGAPPv2\\backend\\tests\\test_api_routes.py</path>\n<type>file</type>\n<content>1: \"\"\"\n2: Backend API route tests using unittest and FastAPI TestClient.\n3: \n4: Tests cover health, settings, memories, documents, and chat endpoints.\n5: All external services (LLM, vector store) are mocked for deterministic tests.\n6: \"\"\"\n7: \n8: import json\n9: import os\n10: import sqlite3\n11: import sys\n12: import tempfile\n13: import unittest\n14: from pathlib import Path\n15: from unittest.mock import AsyncMock, MagicMock, patch\n16: \n17: # Add parent directory to path for imports\n18: sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))\n19: \n20: # Stub missing optional dependencies\n21: try:\n22:     import lancedb\n23: except ImportError:\n24:     import types\n25:     sys.modules['lancedb'] = types.ModuleType('lancedb')\n26: \n27: try:\n28:     import pyarrow\n29: except ImportError:\n30:     import types\n31:     sys.modules['pyarrow'] = types.ModuleType('pyarrow')\n32: \n33: try:\n34:     from unstructured.partition.auto import partition\n35: except ImportError:\n36:     import types\n37:     _unstructured = types.ModuleType('unstructured')\n38:     _unstructured.__path__ = []\n39:     _unstructured.partition = types.ModuleType('unstructured.partition')\n40:     _unstructured.partition.__path__ = []\n41:     _unstructured.partition.auto = types.ModuleType('unstructured.partition.auto')\n42:     _unstructured.partition.auto.partition = lambda *args, **kwargs: []\n43:     _unstructured.chunking = types.ModuleType('unstructured.chunking')\n44:     _unstructured.chunking.__path__ = []\n45:     _unstructured.chunking.title = types.ModuleType('unstructured.chunking.title')\n46:     _unstructured.chunking.title.chunk_by_title = lambda *args, **kwargs: []\n47:     _unstructured.documents = types.ModuleType('unstructured.documents')\n48:     _unstructured.documents.__path__ = []\n49:     _unstructured.documents.elements = types.ModuleType('unstructured.documents.elements')\n50:     _unstructured.documents.elements.Element = type('Element', (), {})\n51:     sys.modules['unstructured'] = _unstructured\n52:     sys.modules['unstructured.partition'] = _unstructured.partition\n53:     sys.modules['unstructured.partition.auto'] = _unstructured.partition.auto\n54:     sys.modules['unstructured.chunking'] = _unstructured.chunking\n55:     sys.modules['unstructured.chunking.title'] = _unstructured.chunking.title\n56:     sys.modules['unstructured.documents'] = _unstructured.documents\n57:     sys.modules['unstructured.documents.elements'] = _unstructured.documents.elements\n58: \n59: from fastapi.testclient import TestClient\n60: \n61: from app.api.deps import get_llm_health_checker, get_model_checker\n62: \n63: \n64: # Create a temporary database for testing\n65: TEST_DB_PATH = None\n66: TEST_DATA_DIR = None\n67: \n68: \n69: def setup_test_db():\n70:     \"\"\"Set up a temporary test database.\"\"\"\n71:     global TEST_DB_PATH, TEST_DATA_DIR\n72:     TEST_DATA_DIR = tempfile.mkdtemp()\n73:     TEST_DB_PATH = Path(TEST_DATA_DIR) / \"test.db\"\n74:     \n75:     # Import and initialize the database\n76:     from app.models.database import init_db\n77:     init_db(str(TEST_DB_PATH))\n78:     return str(TEST_DB_PATH)\n79: \n80: \n81: def get_test_settings():\n82:     \"\"\"Get test settings with temporary database path.\"\"\"\n83:     from app.config import Settings\n84:     \n85:     settings = Settings()\n86:     settings.data_dir = Path(TEST_DATA_DIR)\n87:     return settings\n88: \n89: \n90: # Set up test database before importing app\n91: setup_test_db()\n92: \n93: from app.main import app\n94: from app.config import settings\n95: \n96: \n97: class TestHealthEndpoint(unittest.TestCase):\n98:     \"\"\"Tests for the /api/health endpoint.\"\"\"\n99:     \n100:     def setUp(self):\n101:         self.client = TestClient(app)\n102:     \n103:     def test_health_check_success(self):\n104:         \"\"\"Test health check returns ok status with mocked services.\"\"\"\n105:         # Mock LLMHealthChecker\n106:         mock_llm_checker = MagicMock()\n107:         mock_llm_checker.check_all = AsyncMock(return_value={\n108:             \"ok\": True,\n109:             \"embeddings\": {\"ok\": True, \"error\": None},\n110:             \"chat\": {\"ok\": True, \"error\": None},\n111:             \"error\": None\n112:         })\n113: \n114:         # Mock ModelChecker\n115:         mock_model_checker = MagicMock()\n116:         mock_model_checker.check_models = AsyncMock(return_value={\n117:             \"embedding_model\": {\"available\": True, \"error\": None},\n118:             \"chat_model\": {\"available\": True, \"error\": None}\n119:         })\n120: \n121:         app.dependency_overrides[get_llm_health_checker] = lambda: mock_llm_checker\n122:         app.dependency_overrides[get_model_checker] = lambda: mock_model_checker\n123: \n124:         try:\n125:             response = self.client.get(\"/api/health\")\n126: \n127:             self.assertEqual(response.status_code, 200)\n128:             data = response.json()\n129:             self.assertEqual(data[\"status\"], \"ok\")\n130:             self.assertIn(\"llm\", data)\n131:             self.assertIn(\"models\", data)\n132:             self.assertTrue(data[\"llm\"][\"ok\"])\n133:         finally:\n134:             app.dependency_overrides.pop(get_llm_health_checker, None)\n135:             app.dependency_overrides.pop(get_model_checker, None)\n136: \n137:     def test_health_check_llm_failure(self):\n138:         \"\"\"Test health check handles LLM service failure.\"\"\"\n139:         mock_llm_checker = MagicMock()\n140:         mock_llm_checker.check_all = AsyncMock(return_value={\n141:             \"ok\": False,\n142:             \"embeddings\": {\"ok\": False, \"error\": \"Embedding service error\"},\n143:             \"chat\": {\"ok\": True, \"error\": None},\n144:             \"error\": \"Embedding service error\"\n145:         })\n146: \n147:         mock_model_checker = MagicMock()\n148:         mock_model_checker.check_models = AsyncMock(return_value={\n149:             \"embedding_model\": {\"available\": True, \"error\": None},\n150:             \"chat_model\": {\"available\": True, \"error\": None}\n151:         })\n152: \n153:         app.dependency_overrides[get_llm_health_checker] = lambda: mock_llm_checker\n154:         app.dependency_overrides[get_model_checker] = lambda: mock_model_checker\n155: \n156:         try:\n157:             response = self.client.get(\"/api/health\")\n158: \n159:             self.assertEqual(response.status_code, 200)\n160:             data = response.json()\n161:             self.assertEqual(data[\"status\"], \"ok\")\n162:             self.assertFalse(data[\"llm\"][\"ok\"])\n163:         finally:\n164:             app.dependency_overrides.pop(get_llm_health_checker, None)\n165:             app.dependency_overrides.pop(get_model_checker, None)\n166: \n167: \n168: class TestSettingsEndpoints(unittest.TestCase):\n169:     \"\"\"Tests for the /api/settings GET and POST endpoints.\"\"\"\n170:     \n171:     def setUp(self):\n172:         self.client = TestClient(app)\n173:         # Store original values\n174:         self._original_chunk_size = settings.chunk_size\n175:         self._original_rag_threshold = settings.rag_relevance_threshold\n176:         # Override get_db to use a pool that allows cross-thread usage\n177:         from app.models.database import get_pool\n178:         from app.api.deps import get_db\n179: \n180:         self._test_pool = get_pool(str(TEST_DB_PATH))\n181: \n182:         def override_get_db():\n183:             conn = self._test_pool.get_connection()\n184:             try:\n185:                 yield conn\n186:             finally:\n187:                 self._test_pool.release_connection(conn)\n188: \n189:         app.dependency_overrides[get_db] = override_get_db\n190:         self._get_db = get_db\n191:     \n192:     def tearDown(self):\n193:         # Restore original values\n194:         settings.chunk_size = self._original_chunk_size\n195:         settings.rag_relevance_threshold = self._original_rag_threshold\n196:         # Restore get_db dependency\n197:         app.dependency_overrides.pop(self._get_db, None)\n198:     \n199:     def test_get_settings(self):\n200:         \"\"\"Test GET /api/settings returns current settings.\"\"\"\n201:         response = self.client.get(\"/api/settings\")\n202:         \n203:         self.assertEqual(response.status_code, 200)\n204:         data = response.json()\n205:         self.assertIn(\"chunk_size\", data)\n206:         self.assertIn(\"rag_relevance_threshold\", data)\n207:         self.assertIn(\"embedding_batch_size\", data)\n208:     \n209:     def test_post_settings_valid(self):\n210:         \"\"\"Test POST /api/settings with valid settings updates values.\"\"\"\n211:         payload = {\n212:             \"chunk_size\": 1024,\n213:             \"rag_relevance_threshold\": 0.5,\n214:             \"embedding_batch_size\": 256\n215:         }\n216:         \n217:         response = self.client.post(\"/api/settings\", json=payload)\n218:         \n219:         self.assertEqual(response.status_code, 200)\n220:         data = response.json()\n221:         self.assertEqual(data[\"chunk_size\"], 1024)\n222:         self.assertEqual(data[\"rag_relevance_threshold\"], 0.5)\n223:         self.assertEqual(data[\"embedding_batch_size\"], 256)\n224:     \n225:     def test_post_settings_invalid_chunk_size(self):\n226:         \"\"\"Test POST /api/settings with invalid chunk_size returns 422.\"\"\"\n227:         payload = {\"chunk_size\": 0}\n228:         \n229:         response = self.client.post(\"/api/settings\", json=payload)\n230:         \n231:         self.assertEqual(response.status_code, 422)\n232:     \n233:     def test_post_settings_invalid_rag_threshold_low(self):\n234:         \"\"\"Test POST /api/settings with rag_relevance_threshold < 0 returns 422.\"\"\"\n235:         payload = {\"rag_relevance_threshold\": -0.1}\n236:         \n237:         response = self.client.post(\"/api/settings\", json=payload)\n238:         \n239:         self.assertEqual(response.status_code, 422)\n240:     \n241:     def test_post_settings_invalid_rag_threshold_high(self):\n242:         \"\"\"Test POST /api/settings with rag_relevance_threshold > 1 returns 422.\"\"\"\n243:         payload = {\"rag_relevance_threshold\": 1.5}\n244:         \n245:         response = self.client.post(\"/api/settings\", json=payload)\n246:         \n247:         self.assertEqual(response.status_code, 422)\n248:     \n249:     def test_post_settings_no_valid_fields(self):\n250:         \"\"\"Test POST /api/settings with no valid fields returns 400.\"\"\"\n251:         payload = {}\n252:         \n253:         response = self.client.post(\"/api/settings\", json=payload)\n254:         \n255:         self.assertEqual(response.status_code, 400)\n256:         data = response.json()\n257:         self.assertIn(\"No valid fields provided\", data[\"detail\"])\n258: \n259: \n260: class TestMemoriesEndpoints(unittest.TestCase):\n261:     \"\"\"Tests for the /api/memories CRUD endpoints.\"\"\"\n262: \n263:     def setUp(self):\n264:         self.client = TestClient(app)\n265:         self._temp_dir = tempfile.mkdtemp()\n266: \n267:         # Initialize test database\n268:         from app.models.database import init_db\n269:         db_path = str(Path(self._temp_dir) / \"test.db\")\n270:         init_db(db_path)\n271: \n272:         # Create a real MemoryStore pointing to test DB\n273:         from app.services.memory_store import MemoryStore\n274:         from app.models.database import SQLiteConnectionPool\n275:         self.test_pool = SQLiteConnectionPool(db_path, max_size=2)\n276:         test_store = MemoryStore(pool=self.test_pool)\n277: \n278:         # Override get_db to use a pool that allows cross-thread usage\n279:         # Create a simple pool for testing\n280:         import sqlite3\n281:         from app.api.deps import get_db, get_memory_store\n282:         from queue import Queue, Empty\n283:         import threading\n284: \n285:         class SimpleConnectionPool:\n286:             def __init__(self, db_path):\n287:                 self.db_path = db_path\n288:                 self._pool = Queue(maxsize=5)\n289:                 self._lock = threading.Lock()\n290:                 self._closed = False\n291: \n292:             def get_connection(self):\n293:                 if self._closed:\n294:                     raise RuntimeError(\"Pool closed\")\n295:                 try:\n296:                     return self._pool.get_nowait()\n297:                 except Empty:\n298:                     return self._create_connection()\n299: \n300:             def _create_connection(self):\n301:                 conn = sqlite3.connect(self.db_path, check_same_thread=False)\n302:                 conn.row_factory = sqlite3.Row\n303:                 conn.execute(\"PRAGMA foreign_keys = ON;\")\n304:                 return conn\n305: \n306:             def release_connection(self, conn):\n307:                 if not self._closed:\n308:                     try:\n309:                         self._pool.put_nowait(conn)\n310:                     except:\n311:                         conn.close()\n312: \n313:             def close_all(self):\n314:                 self._closed = True\n315:                 while True:\n316:                     try:\n317:                         conn = self._pool.get_nowait()\n318:                         conn.close()\n319:                     except Empty:\n320:                         break\n321: \n322:         self._connection_pool = SimpleConnectionPool(db_path)\n323: \n324:         def override_get_db():\n325:             conn = self._connection_pool.get_connection()\n326:             try:\n327:                 yield conn\n328:             finally:\n329:                 self._connection_pool.release_connection(conn)\n330: \n331:         app.dependency_overrides[get_db] = override_get_db\n332:         app.dependency_overrides[get_memory_store] = lambda: test_store\n333:         self._test_store = test_store\n334:         self._db_path = db_path\n335:         self._get_db = get_db\n336:         self._get_memory_store = get_memory_store\n337: \n338:     def tearDown(self):\n339:         app.dependency_overrides.pop(self._get_db, None)\n340:         app.dependency_overrides.pop(self._get_memory_store, None)\n341:         if hasattr(self, 'test_pool'):\n342:             self.test_pool.close_all()\n343:         if hasattr(self, '_connection_pool'):\n344:             self._connection_pool.close_all()\n345:         import shutil\n346:         shutil.rmtree(self._temp_dir, ignore_errors=True)\n347:     \n348:     def test_list_memories_empty(self):\n349:         \"\"\"Test GET /api/memories returns empty list when no memories.\"\"\"\n350:         response = self.client.get(\"/api/memories\")\n351:         \n352:         self.assertEqual(response.status_code, 200)\n353:         data = response.json()\n354:         self.assertEqual(data[\"memories\"], [])\n355: \n356:     def test_create_memory(self):\n357:         \"\"\"Test POST /api/memories creates a new memory.\"\"\"\n358:         payload = {\n359:             \"content\": \"Test memory content\",\n360:             \"category\": \"test\",\n361:             \"tags\": \"[\\\"tag1\\\", \\\"tag2\\\"]\",\n362:             \"source\": \"test_source\"\n363:         }\n364: \n365:         response = self.client.post(\"/api/memories\", json=payload)\n366: \n367:         self.assertEqual(response.status_code, 200)\n368:         data = response.json()\n369:         self.assertEqual(data[\"content\"], \"Test memory content\")\n370:         self.assertEqual(data[\"metadata\"][\"category\"], \"test\")\n371:         self.assertEqual(data[\"id\"], \"1\")  # id is now a string\n372: \n373:     def test_create_memory_invalid_empty_content(self):\n374:         \"\"\"Test POST /api/memories with empty content returns 422.\"\"\"\n375:         payload = {\n376:             \"content\": \"\",\n377:             \"category\": \"test\"\n378:         }\n379: \n380:         response = self.client.post(\"/api/memories\", json=payload)\n381: \n382:         self.assertEqual(response.status_code, 422)\n383:     \n384:     def test_create_and_list_memory(self):\n385:         \"\"\"Test creating a memory and then listing it.\"\"\"\n386:         # Create a memory\n387:         create_payload = {\n388:             \"content\": \"Integration test memory\",\n389:             \"category\": \"integration\",\n390:             \"tags\": \"[\\\"test\\\"]\"\n391:         }\n392:         \n393:         create_response = self.client.post(\"/api/memories\", json=create_payload)\n394:         self.assertEqual(create_response.status_code, 200)\n395:         created = create_response.json()\n396:         self.assertEqual(created[\"content\"], \"Integration test memory\")\n397:         \n398:         # List memories\n399:         list_response = self.client.get(\"/api/memories\")\n400:         self.assertEqual(list_response.status_code, 200)\n401:         data = list_response.json()\n402:         self.assertEqual(len(data[\"memories\"]), 1)\n403:         self.assertEqual(data[\"memories\"][0][\"content\"], \"Integration test memory\")\n404:     \n405:     def test_update_memory(self):\n406:         \"\"\"Test PUT /api/memories/{id} updates a memory.\"\"\"\n407:         # Create a memory first\n408:         create_payload = {\n409:             \"content\": \"Original content\",\n410:             \"category\": \"original\"\n411:         }\n412:         create_response = self.client.post(\"/api/memories\", json=create_payload)\n413:         self.assertEqual(create_response.status_code, 200)\n414:         memory_id = create_response.json()[\"id\"]\n415: \n416:         # Update the memory\n417:         update_payload = {\n418:             \"content\": \"Updated content\",\n419:             \"category\": \"updated\"\n420:         }\n421:         update_response = self.client.put(f\"/api/memories/{memory_id}\", json=update_payload)\n422: \n423:         self.assertEqual(update_response.status_code, 200)\n424:         data = update_response.json()\n425:         self.assertEqual(data[\"content\"], \"Updated content\")\n426:         self.assertEqual(data[\"metadata\"][\"category\"], \"updated\")\n427:     \n428:     def test_update_memory_not_found(self):\n429:         \"\"\"Test PUT /api/memories/{id} returns 404 for non-existent memory.\"\"\"\n430:         update_payload = {\"content\": \"Updated content\"}\n431:         \n432:         response = self.client.put(\"/api/memories/99999\", json=update_payload)\n433:         \n434:         self.assertEqual(response.status_code, 404)\n435:     \n436:     def test_delete_memory(self):\n437:         \"\"\"Test DELETE /api/memories/{id} deletes a memory.\"\"\"\n438:         # Create a memory first\n439:         create_payload = {\"content\": \"Memory to delete\"}\n440:         create_response = self.client.post(\"/api/memories\", json=create_payload)\n441:         self.assertEqual(create_response.status_code, 200)\n442:         memory_id = create_response.json()[\"id\"]\n443:         \n444:         # Delete the memory\n445:         delete_response = self.client.delete(f\"/api/memories/{memory_id}\")\n446:         \n447:         self.assertEqual(delete_response.status_code, 200)\n448:         data = delete_response.json()\n449:         self.assertIn(\"deleted successfully\", data[\"message\"])\n450:         \n451:         # Verify it's gone\n452:         list_response = self.client.get(\"/api/memories\")\n453:         self.assertEqual(len(list_response.json()[\"memories\"]), 0)\n454:     \n455:     def test_delete_memory_not_found(self):\n456:         \"\"\"Test DELETE /api/memories/{id} returns 404 for non-existent memory.\"\"\"\n457:         response = self.client.delete(\"/api/memories/99999\")\n458:         \n459:         self.assertEqual(response.status_code, 404)\n460: \n461: \n462: class TestDocumentsEndpoints(unittest.TestCase):\n463:     \"\"\"Tests for the /api/documents endpoints.\"\"\"\n464: \n465:     def setUp(self):\n466:         self.client = TestClient(app)\n467:         self._temp_dir = tempfile.mkdtemp()\n468:         db_path = str(Path(self._temp_dir) / \"test.db\")\n469: \n470:         from app.models.database import init_db\n471:         init_db(db_path)\n472: \n473:         # Override get_db to use a pool that allows cross-thread usage\n474:         # Create a simple pool for testing\n475:         import sqlite3\n476:         from app.api.deps import get_db\n477:         from queue import Queue, Empty\n478:         import threading\n479: \n480:         class SimpleConnectionPool:\n481:             def __init__(self, db_path):\n482:                 self.db_path = db_path\n483:                 self._pool = Queue(maxsize=5)\n484:                 self._lock = threading.Lock()\n485:                 self._closed = False\n486: \n487:             def get_connection(self):\n488:                 if self._closed:\n489:                     raise RuntimeError(\"Pool closed\")\n490:                 try:\n491:                     return self._pool.get_nowait()\n492:                 except Empty:\n493:                     return self._create_connection()\n494: \n495:             def _create_connection(self):\n496:                 conn = sqlite3.connect(self.db_path, check_same_thread=False)\n497:                 conn.row_factory = sqlite3.Row\n498:                 conn.execute(\"PRAGMA foreign_keys = ON;\")\n499:                 return conn\n500: \n501:             def release_connection(self, conn):\n502:                 if not self._closed:\n503:                     try:\n504:                         self._pool.put_nowait(conn)\n505:                     except:\n506:                         conn.close()\n507: \n508:             def close_all(self):\n509:                 self._closed = True\n510:                 while True:\n511:                     try:\n512:                         conn = self._pool.get_nowait()\n513:                         conn.close()\n514:                     except Empty:\n515:                         break\n516: \n517:         self._connection_pool = SimpleConnectionPool(db_path)\n518: \n519:         def override_get_db():\n520:             conn = self._connection_pool.get_connection()\n521:             try:\n522:                 yield conn\n523:             finally:\n524:                 self._connection_pool.release_connection(conn)\n525: \n526:         app.dependency_overrides[get_db] = override_get_db\n527:         self._db_path = db_path\n528:         self._get_db = get_db\n529: \n530:     def tearDown(self):\n531:         app.dependency_overrides.pop(self._get_db, None)\n532:         if hasattr(self, '_connection_pool'):\n533:             self._connection_pool.close_all()\n534:         import shutil\n535:         shutil.rmtree(self._temp_dir, ignore_errors=True)\n536: \n537:     def test_get_document_stats_empty(self):\n538:         \"\"\"Test GET /api/documents/stats returns success with zero counts.\"\"\"\n539:         response = self.client.get(\"/api/documents/stats\")\n540: \n541:         self.assertEqual(response.status_code, 200)\n542:         data = response.json()\n543:         self.assertEqual(data[\"total_files\"], 0)\n544:         self.assertEqual(data[\"total_chunks\"], 0)\n545:         self.assertEqual(data[\"status\"], \"success\")\n546: \n547:     def test_list_documents_empty(self):\n548:         \"\"\"Test GET /api/documents returns empty list when no documents.\"\"\"\n549:         response = self.client.get(\"/api/documents/\")\n550: \n551:         self.assertEqual(response.status_code, 200)\n552:         data = response.json()\n553:         self.assertEqual(data[\"documents\"], [])\n554: \n555: \n556: class TestChatEndpoint(unittest.TestCase):\n557:     \"\"\"Tests for the /api/chat endpoint with mocked RAGEngine.\"\"\"\n558: \n559:     def setUp(self):\n560:         self.client = TestClient(app)\n561: \n562:     def tearDown(self):\n563:         from app.api.deps import get_rag_engine\n564:         app.dependency_overrides.pop(get_rag_engine, None)\n565: \n566:     def _set_mock_rag_engine(self, mock_query_fn):\n567:         \"\"\"Helper to override get_rag_engine with a mock that uses the given query function.\"\"\"\n568:         from app.api.deps import get_rag_engine\n569:         mock_engine = MagicMock()\n570:         mock_engine.query = mock_query_fn\n571:         app.dependency_overrides[get_rag_engine] = lambda: mock_engine\n572: \n573:     def test_chat_non_streaming(self):\n574:         \"\"\"Test POST /api/chat non-streaming returns content and sources.\"\"\"\n575: \n576:         async def mock_query(user_input, chat_history, stream=False, **kwargs):\n577:             \"\"\"Mock async generator for RAG query.\"\"\"\n578:             yield {\"type\": \"content\", \"content\": \"This is a test response.\"}\n579:             yield {\n580:                 \"type\": \"done\",\n581:                 \"sources\": [\n582:                     {\"file_id\": \"1\", \"score\": 0.95, \"metadata\": {\"source_file\": \"test.txt\"}},\n583:                     {\"file_id\": \"2\", \"score\": 0.85, \"metadata\": {\"source_file\": \"test2.txt\"}}\n584:                 ],\n585:                 \"memories_used\": [\"Memory 1\"]\n586:             }\n587: \n588:         self._set_mock_rag_engine(mock_query)\n589: \n590:         payload = {\n591:             \"message\": \"What is the test?\",\n592:             \"history\": [],\n593:             \"stream\": False\n594:         }\n595: \n596:         response = self.client.post(\"/api/chat\", json=payload)\n597: \n598:         self.assertEqual(response.status_code, 200)\n599:         data = response.json()\n600:         self.assertEqual(data[\"content\"], \"This is a test response.\")\n601:         self.assertEqual(len(data[\"sources\"]), 2)\n602:         self.assertEqual(data[\"sources\"][0][\"file_id\"], \"1\")\n603:         self.assertEqual(len(data[\"memories_used\"]), 1)\n604: \n605:     def test_chat_non_streaming_with_history(self):\n606:         \"\"\"Test POST /api/chat with chat history.\"\"\"\n607: \n608:         async def mock_query(user_input, chat_history, stream=False, **kwargs):\n609:             \"\"\"Mock async generator that verifies history is passed.\"\"\"\n610:             # Verify history is passed\n611:             self.assertEqual(len(chat_history), 1)\n612:             self.assertEqual(chat_history[0][\"role\"], \"user\")\n613:             self.assertEqual(chat_history[0][\"content\"], \"Previous message\")\n614: \n615:             yield {\"type\": \"content\", \"content\": \"Response with history.\"}\n616:             yield {\n617:                 \"type\": \"done\",\n618:                 \"sources\": [],\n619:                 \"memories_used\": []\n620:             }\n621: \n622:         self._set_mock_rag_engine(mock_query)\n623: \n624:         payload = {\n625:             \"message\": \"Follow-up question\",\n626:             \"history\": [{\"role\": \"user\", \"content\": \"Previous message\"}],\n627:             \"stream\": False\n628:         }\n629: \n630:         response = self.client.post(\"/api/chat\", json=payload)\n631: \n632:         self.assertEqual(response.status_code, 200)\n633:         data = response.json()\n634:         self.assertEqual(data[\"content\"], \"Response with history.\")\n635: \n636:     def test_chat_empty_sources(self):\n637:         \"\"\"Test POST /api/chat handles empty sources gracefully.\"\"\"\n638: \n639:         async def mock_query(user_input, chat_history, stream=False, **kwargs):\n640:             yield {\"type\": \"content\", \"content\": \"No relevant sources found.\"}\n641:             yield {\n642:                 \"type\": \"done\",\n643:                 \"sources\": [],\n644:                 \"memories_used\": []\n645:             }\n646: \n647:         self._set_mock_rag_engine(mock_query)\n648: \n649:         payload = {\n650:             \"message\": \"Unknown query\",\n651:             \"history\": [],\n652:             \"stream\": False\n653:         }\n654: \n655:         response = self.client.post(\"/api/chat\", json=payload)\n656: \n657:         self.assertEqual(response.status_code, 200)\n658:         data = response.json()\n659:         self.assertEqual(data[\"content\"], \"No relevant sources found.\")\n660:         self.assertEqual(data[\"sources\"], [])\n661:         self.assertEqual(data[\"memories_used\"], [])\n662: \n663: \n664: class TestBasicHealthEndpoint(unittest.TestCase):\n665:     \"\"\"Tests for the basic /health endpoint.\"\"\"\n666:     \n667:     def setUp(self):\n668:         self.client = TestClient(app)\n669:     \n670:     def test_basic_health_check(self):\n671:         \"\"\"Test GET /health returns ok status.\"\"\"\n672:         response = self.client.get(\"/health\")\n673:         \n674:         self.assertEqual(response.status_code, 200)\n675:         data = response.json()\n676:         self.assertEqual(data[\"status\"], \"ok\")\n677: \n678: \n679: if __name__ == \"__main__\":\n680:     unittest.main()\n\n(End of file - total 680 lines)\n</content>","timestamp":1771896267417,"originalBytes":28091}